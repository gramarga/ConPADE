<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Bio.Desktop</name>
    </assembly>
    <members>
        <member name="T:Bio.Matrix.AbstractMatrixView`3">
            <summary>
            An abstract wrapper used to store common code by several of the other matrix views.
            </summary>
            <typeparam name="TRowKey">The type of the row key. Usually "String"</typeparam>
            <typeparam name="TColKey">The type of the col key. Usually "String"</typeparam>
            <typeparam name="TValue">The type of the value, for example, double, int, char, etc.</typeparam>
        </member>
        <member name="T:Bio.Matrix.Matrix`3">
            <summary>
            A 2-D collection of values, accessable via a pair of indexes or a pair of keys.
            </summary>
            <typeparam name="TRowKey">The type of the row key. Usually "String"</typeparam>
            <typeparam name="TColKey">The type of the col key. Usually "String"</typeparam>
            <typeparam name="TValue">The type of the value, for example, double, int, char, etc.</typeparam>
        </member>
        <member name="M:Bio.Matrix.Matrix`3.RowView(`0)">
            <summary>
            Gets a row in the form of an IDictionary.
            </summary>
            <param name="rowKey">The key for the row of interest. The key must exist in RowKeys (and, thus, IndexOfRowKey)</param>
            <returns>An IDictionary that maps col keys to (nonmissing) values. Values in the dictionary may be read, set, or added.
            Values changes are reflected in the Matrix. Any values added to the dictionary must have a key that already
            exists in the ColKeys (and, thus, IndexOfColKeys) of the Matrix.
            The RowView method is at least O(log n) and typically O(1).
            Access in the dictionary is at least O(log n) and typically O(1).
            </returns>
        </member>
        <member name="M:Bio.Matrix.Matrix`3.TryGetValue(`0,`1,`2@)">
            <summary>
            Gets the value associated with the specified keys, if a value is not missing.
            </summary>
            <param name="rowKey">The key for the row of interest. The key must exist in RowKeys (and, thus, IndexOfRowKey)</param>
            <param name="colKey">The key for the col of interest. The key must exist in ColKeys (and, thus, IndexOfColKey)</param>
            <param name="value">When this method returns, contains the value associated with the specified keys, if the value is not missing;
            otherwise, the default value for the type of the value parameter. This parameter is passed uninitialized.</param>
            <returns>true if the matrix contains an element with the specified keys; otherwise, false.</returns>
        </member>
        <member name="M:Bio.Matrix.Matrix`3.TryGetValue(System.Int32,System.Int32,`2@)">
            <summary>
            Gets the value associated with the specified integer indexes, if a value is not missing.
            </summary>
            <param name="rowIndex">The index for the row of interest</param>
            <param name="colIndex">The index for the col of interest</param>
            <param name="value">When this method returns, contains the value associated with the specified indexes, if the value is not missing;
            otherwise, the missing value is returned. This parameter is passed uninitialized.</param>
            <returns>true if the matrix contains an element with the specified indexes; otherwise, false.</returns>
        </member>
        <member name="M:Bio.Matrix.Matrix`3.GetValueOrMissing(`0,`1)">
            <summary>
            Gets the value associated with the specified keys or the special Missing value.
            </summary>
            <param name="rowKey">The key for the row of interest. The key must exist in RowKeys (and, thus, IndexOfRowKey)</param>
            <param name="colKey">The key for the col of interest. The key must exist in ColKeys (and, thus, IndexOfColKey)</param>
            <returns>a value if the matrix contains an element with the specified keys; otherwise, the special Missing value.</returns>
        </member>
        <member name="M:Bio.Matrix.Matrix`3.GetValueOrMissing(System.Int32,System.Int32)">
            <summary>
            Gets the value associated with the specified indexes or the special Missing value.
            </summary>
            <param name="rowIndex">The index for the row of interest</param>
            <param name="colIndex">The index for the col of interest</param>
            <returns>a value if the matrix contains an element with the specified indexes; otherwise, the special Missing value.</returns>
        </member>
        <member name="M:Bio.Matrix.Matrix`3.SetValueOrMissing(`0,`1,`2)">
            <summary>
            Set a value in the matrix or, by using the special Missing value, mark an element as missing.
            </summary>
            <param name="rowKey">The key for the row of interest. The key must exist in RowKeys (and, thus, IndexOfRowKey)</param>
            <param name="colKey">The key for the col of interest. The key must exist in ColKeys (and, thus, IndexOfColKey)</param>
            <param name="value">The value to set or the special Missing value.</param>
        </member>
        <member name="M:Bio.Matrix.Matrix`3.SetValueOrMissing(System.Int32,System.Int32,`2)">
            <summary>
            Set a value in the matrix or, by using the special Missing value, mark an element as missing.
            </summary>
            <param name="rowIndex">The index for the row of interest</param>
            <param name="colIndex">The index for the col of interest</param>
            <param name="value">The value to set or the special Missing value.</param>
        </member>
        <member name="M:Bio.Matrix.Matrix`3.Remove(`0,`1)">
            <summary>
            Removes the value with the specified keys from the Matrix.
            </summary>
            <param name="rowKey">The key for the row of interest. The key must exist in RowKeys (and, thus, IndexOfRowKey)</param>
            <param name="colKey">The key for the col of interest. The key must exist in ColKeys (and, thus, IndexOfColKey)</param>
            <returns>true if the element is successfully found and removed; otherwise, false.
            This method returns false if the value is already missing from the Matrix.</returns>
        </member>
        <member name="M:Bio.Matrix.Matrix`3.Remove(System.Int32,System.Int32)">
            <summary>
            Removes the value with the specified indexes from the Matrix.
            </summary>
            <param name="rowIndex">The index for the row of interest</param>
            <param name="colIndex">The index for the col of interest</param>
            <returns>true if the element is successfully found and removed; otherwise, false.
            This method returns false if the value is already missing from the Matrix.</returns>
        </member>
        <member name="M:Bio.Matrix.Matrix`3.IsMissing(`2)">
            <summary>
            Tells if the value is the special missing value. (Unlike 'Equals', this works even if the special missing value is null.)
            </summary>
            <param name="value">The value to test</param>
            <returns>true if the value is the special missing value</returns>
        </member>
        <member name="M:Bio.Matrix.Matrix`3.IsMissing(`0,`1)">
            <summary>
            Determines if the Matrix is missing a value.
            </summary>
            <param name="rowKey">The key for the row of interest. The key must exist in RowKeys (and, thus, IndexOfRowKey)</param>
            <param name="colKey">The key for the col of interest. The key must exist in ColKeys (and, thus, IndexOfColKey)</param>
            <returns>true if the matrix contains an element with the specified keys; otherwise, false.</returns>
        </member>
        <member name="M:Bio.Matrix.Matrix`3.IsMissing(System.Int32,System.Int32)">
            <summary>
            Determines if the Matrix is missing a value.
            </summary>
            <param name="rowIndex">The index for the row of interest</param>
            <param name="colIndex">The index for the col of interest</param>
            <returns>true if the matrix contains an element with the specified indexes; otherwise, false.</returns>
        </member>
        <member name="M:Bio.Matrix.Matrix`3.ContainsRowAndColKeys(`0,`1)">
            <summary>
            Determines whether the Matrix contains the specified keys.
            The method is at least O(log n) and typically O(1).
            </summary>
            <param name="rowKey">A row key of interest. It need not exist in RowKeys (and thus, IndexOfRowKeys)</param>
            <param name="colKey">A col key of interest. It need not exist in ColKeys (and thus, IndexOfColKeys)</param>
            <returns>true if RowKeys contrains rowKey and ColKeys contains colKey; otherwise, false.</returns>
        </member>
        <member name="M:Bio.Matrix.Matrix`3.ContainsRowKey(`0)">
            <summary>
            Determines whether the Matrix contains the specified row key.
            The method is at least O(log n) and typically O(1).
            </summary>
            <param name="rowKey">A row key of interest. It need not exist in RowKeys (and thus, IndexOfRowKeys)</param>
            <returns>true if RowKeys contrains rowKey; otherwise, false.</returns>
        </member>
        <member name="M:Bio.Matrix.Matrix`3.ContainsColKey(`1)">
            <summary>
            Determines whether the Matrix contains the specified col key.
            The method is at least O(log n) and typically O(1).
            </summary>
            <param name="colKey">A row key of interest. It need not exist in ColKeys (and thus, IndexOfColKeys)</param>
            <returns>true if ColKeys contrains colKey; otherwise, false.</returns>
        </member>
        <member name="M:Bio.Matrix.Matrix`3.RowView(System.Int32)">
            <summary>
            Gets a row in the form of an IDictionary.
            </summary>
            <param name="rowIndex">The index for the row of interest</param>
            <returns>An IDictionary that maps col keys to (nonmissing) values. Values in the dictionary may be read, set, or added.
            Values changes are reflected in the Matrix. Any values added to the dictionary must have a key that already
            exists in the ColKeys (and, thus, IndexOfColKeys) of the Matrix.
            The RowView method is at least O(log n) and typically O(1).
            Access in the dictionary is at least O(log n) and typically O(1).
            </returns>
        </member>
        <member name="M:Bio.Matrix.Matrix`3.ColView(`1)">
            <summary>
            Gets a col in the form of an IDictionary.
            </summary>
            <param name="colKey">The key for the col of interest. The key must exist in ColKeys (and, thus, IndexOfColKey)</param>
            <returns>An IDictionary that maps row keys to (nonmissing) values. Values in the dictionary may be read, set, or added.
            Values changes are reflected in the Matrix. Any values added to the dictionary must have a key that already
            exists in the RowKeys (and, thus, IndexOfRowKeys) of the Matrix.
            The ColView method is at least O(log n) and typically O(1).
            Access in the dictionary is at least O(log n) and typically O(1).
            </returns>
        </member>
        <member name="M:Bio.Matrix.Matrix`3.ColView(System.Int32)">
            <summary>
            Gets a col in the form of an IDictionary.
            </summary>
            <param name="colIndex">The index for the col of interest</param>
            <returns>An IDictionary that maps row keys to (nonmissing) values. Values in the dictionary may be read, set, or added.
            Values changes are reflected in the Matrix. Any values added to the dictionary must have a key that already
            exists in the RowKeys (and, thus, IndexOfRowKeys) of the Matrix.
            The ColView method is at least O(log n) and typically O(1).
            Access in the dictionary is at least O(log n) and typically O(1).
            </returns>
        </member>
        <member name="M:Bio.Matrix.Matrix`3.ToString2D">
            <summary>
            Returns a String that represents the Matrix as a series of lines.
            </summary>
            <returns>A string, containing newlines characters, representing the matrix.</returns>
        </member>
        <member name="M:Bio.Matrix.Matrix`3.WriteDense(System.IO.TextWriter)">
            <summary>
            Writes the matrix to a TextWriter in dense format. The first line is "var" TAB and then the tab-delimited col keys.
            Next is one line per row key. Each line is the row key TAB and then the tab-limited values.
            Values may include the special Missing value.
            </summary>
            <param name="textWriter">The TextWriter to write to.</param>
        </member>
        <member name="M:Bio.Matrix.Matrix`3.IsMissingSome">
            <summary>
            Determines of the Matrix contains any missing values.
            May be as slow as O(rowCount * colCount)
            </summary>
            <returns>true if the matrix contains any missing values; otherwise, false.</returns>
        </member>
        <member name="M:Bio.Matrix.Matrix`3.IsMissingAll">
            <summary>
            Determines of the Matrix is completely empty.
            May be as slow as O(rowCount * colCount)
            </summary>
            <returns>true if the matrix contains all missing values; otherwise, false.</returns>
        </member>
        <member name="M:Bio.Matrix.Matrix`3.IsMissingAllInSomeRow">
            <summary>
            Determines if the Matrix contains a row missing all values.
            May be as slow as O(rowCount * colCount)
            </summary>
            <returns>true if the matrix contains a row missing all values; otherwise, false.</returns>
        </member>
        <member name="M:Bio.Matrix.Matrix`3.IsMissingAllInSomeCol">
            <summary>
            Determines if the Matrix contains a column missing all values.
            May be as slow as O(rowCount * colCount)
            </summary>
            <returns>true if the matrix contains a column missing all values; otherwise, false.</returns>
        </member>
        <member name="M:Bio.Matrix.Matrix`3.IsMissingAllInRow(`0)">
            <summary>
            Determines if a row is missing all its values.
            May be as slow as O(log(rowCount) * colCount)
            </summary>
            <param name="rowKey">The key for the row of interest. The key must exist in RowKeys (and, thus, IndexOfRowKey)</param>
            <returns>true is the row specified is missing all its values; otherwise false.</returns>
        </member>
        <member name="M:Bio.Matrix.Matrix`3.IsMissingAllInRow(System.Int32)">
            <summary>
            Determines if a row is missing all its values.
            May be as slow as O(log(rowCount) * colCount)
            </summary>
            <param name="rowIndex">The index for the row of interest</param>
            <returns>true is the row specified is missing all its values; otherwise false.</returns>
        </member>
        <member name="M:Bio.Matrix.Matrix`3.IsMissingAllInCol(`1)">
            <summary>
            Determines if a column is missing all its values.
            May be as slow as O(rowCount * log(colCount))
            </summary>
            <param name="colKey">The key for the col of interest. The key must exist in ColKeys (and, thus, IndexOfColKey)</param>
            <returns>true is the col specified is missing all its values; otherwise false.</returns>
        </member>
        <member name="M:Bio.Matrix.Matrix`3.IsMissingAllInCol(System.Int32)">
            <summary>
            Determines if a column is missing all its values.
            May be as slow as O(rowCount * log(colCount))
            </summary>
            <param name="colIndex">The index for the col of interest</param>
            <returns>true is the col specified is missing all its values; otherwise false.</returns>
        </member>
        <member name="M:Bio.Matrix.Matrix`3.MatrixEquals(Bio.Matrix.Matrix{`0,`1,`2})">
            <summary>
            Determines whether two Matrix&lt;TRowKey,TColKey,TValue&gt; are equal. They are equal if they
              0. The 2nd one is not null
              3. Have the same missing values
              1. have the same rowKeys, in the same order
              2. have the same colKeys, in the same order
              4. Have the same nonmissing values
            May be as slow as O(rowCount * colCount)
            </summary>
            <param name="otherMatrix">The matrix to compare to</param>
            <returns>true, if they are equal in terms of rowKeys, colKeys, missing and nonMissing values. Otherwise, false.</returns>
        </member>
        <member name="P:Bio.Matrix.Matrix`3.Item(System.Int32,System.Int32)">
            <summary>
            Gets or sets the value associated with the specified indexes.
            </summary>
            <param name="rowIndex">The index for the row of interest</param>
            <param name="colIndex">The index for the col of interest</param>
            <returns>The value associated with the specified indexes.
            A get operation will throw an exception if the value is missing from the matrix. (See TryGet and GetValueOrMissing.)
            A set operation will overwrite a missing value but will not set to the special Missing value. (See Remove and SetValueOrMissing).</returns>
        </member>
        <member name="P:Bio.Matrix.Matrix`3.Item(`0,`1)">
            <summary>
            Gets or sets the value associated with the specified keys.
            </summary>
            <param name="rowKey">The key for the row of interest. The key must exist in RowKeys (and, thus, IndexOfRowKey)</param>
            <param name="colKey">The key for the col of interest. The key must exist in ColKeys (and, thus, IndexOfColKey)</param>
            <returns>The value associated with the specified keys.
            A get operation will throw an exception if the value is missing from the matrix. (See TryGet and GetValueOrMissing.)
            A set operation will overwrite a missing value but will not set to the special Missing value. (See Remove and SetValueOrMissing).</returns>
        </member>
        <member name="P:Bio.Matrix.Matrix`3.RowKeys">
            <summary>
            The collection of row keys. As with any collection this is a mapping from
            an index to a value. The collection is read-only and never changes. To get the
            effect of changing this list, a new matrix can be created on top of the current matrix.
            Access is at least O(log n) and typically O(1).
            </summary>
        </member>
        <member name="P:Bio.Matrix.Matrix`3.ColKeys">
            <summary>
            The collection of col keys. As with any collection this is a mapping from
            an index to a value. The collection is read-only and never changes. To get the
            effect of changing this list, a new matrix can be created on top of the current matrix.
            Access is at least O(log n) and typically O(1).
            </summary>
        </member>
        <member name="P:Bio.Matrix.Matrix`3.IndexOfRowKey">
            <summary>
            A dictionary that maps a row index (an integer) to a row key. The
            dictionary is read-only and never changes. To get the
            effect of changing this list, a new matrix can be created on top of the current matrix.
            Access is at least O(log n) and typically O(1).
            </summary>
        </member>
        <member name="P:Bio.Matrix.Matrix`3.IndexOfColKey">
            <summary>
            A dictionary that maps a col index (an integer) to a col key. The
            dictionary is read-only and never changes. To get the
            effect of changing this list, a new matrix can be created on top of the current matrix.
            Access is at least O(log n) and typically O(1).
            </summary>
        </member>
        <member name="P:Bio.Matrix.Matrix`3.RowCount">
            <summary>
            Gets the number of keys in RowKeys. Because RowKeys never changes, this value never changes.
            The property is O(1).
            </summary>
        </member>
        <member name="P:Bio.Matrix.Matrix`3.ColCount">
            <summary>
            Gets the number of keys in ColKeys. Because ColKeys never changes, this value never changes.
            The property is O(1).
            </summary>
        </member>
        <member name="P:Bio.Matrix.Matrix`3.MissingValue">
            <summary>
            The special Missing value.
            This property is O(1).
            </summary>
        </member>
        <member name="P:Bio.Matrix.Matrix`3.Values">
            <summary>
            Gets a sequence containing the nonmissing values in the Matrix.
            </summary>
            <returns>A sequence containing the nonmissing values of the Matrix.</returns>
        </member>
        <member name="P:Bio.Matrix.Matrix`3.RowKeyColKeyValues">
            <summary>
            Returns an enumerator that iterates through the Matrix, skipping any missing values.
            </summary>
            <returns>An enumerator for the Matrix. For purposes of enumeration, each item is a RowKeyColKeyValue structure representing nonmissing value and its keys.</returns>
        </member>
        <member name="M:Bio.Matrix.AbstractMatrixView`3.GetMatrixAndIndex(System.Int32,System.Int32,Bio.Matrix.Matrix{`0,`1,`2}@,System.Int32@,System.Int32@)">
            <summary>
            Given an rowIndex and colIndex returns the appropriate parent matrix and its cooresponding rowIndex and colIndex.
            </summary>
            <param name="rowIndex">a rowIndex into the current matrix</param>
            <param name="colIndex">a colIndex into the current matrix</param>
            <param name="m">the appropriate parment matrix</param>
            <param name="mappedRowIndex">the cooresponding rowIndex in the parent</param>
            <param name="mappedColIndex">the corresponding colIndex in the parent</param>
        </member>
        <member name="M:Bio.Matrix.AbstractMatrixView`3.GetMatrixAndKey(`0,`1,Bio.Matrix.Matrix{`0,`1,`2}@,`0@,`1@)">
            <summary>
            Given an rowKey and colKey returns the appropriate parent matrix and its cooresponding rowKey and colKey.
            </summary>
            <param name="rowKey">a rowKey into the current matrix</param>
            <param name="colKey">a colKey into the current matrix</param>
            <param name="m">the appropriate parment matrix</param>
            <param name="mappedRowKey">the cooresponding rowKey in the parent</param>
            <param name="mappedColKey">the corresponding colKey in the parent</param>
        </member>
        <member name="T:Bio.Matrix.ConvertValueView`4">
            <summary>
            Creates a view on a matrix in which values converted one-to-one. For example, Suppose you have a matrix with
            char values such as '0', '1', '2' (with '?' for missing) and you need doubles (with double.NaN as missing).
            With this class you can wrap your original matrix, making it act like the matrix you need.
            </summary>
            <typeparam name="TRowKey">The type of the row key. Usually "String"</typeparam>
            <typeparam name="TColKey">The type of the col key. Usually "String"</typeparam>
            <typeparam name="TValueView">The type of desired values.</typeparam>
            <typeparam name="TValueParent">The type of the current values.</typeparam>
        </member>
        <member name="M:Bio.Matrix.ConvertValueView`4.#ctor">
            <summary>
            Parameterless constructor. Don't use without setting the member variables with, for example, the SetUp method
            </summary>
        </member>
        <member name="M:Bio.Matrix.ConvertValueView`4.SetUp(Bio.Matrix.Matrix{`0,`1,`3},Bio.Util.ValueConverter{`3,`2},`2)">
            <summary>
            Set all important member variables after using the parameterless constructor.
            </summary>
            <param name="parentMatrix">parent Matrix.</param>
            <param name="converter">The converter.</param>
            <param name="missingValue">The missingValue.</param>
        </member>
        <member name="P:Bio.Matrix.ConvertValueView`4.ParentMatrix">
            <summary>
            Get the original matrix that this view wraps.
            </summary>
        </member>
        <member name="P:Bio.Matrix.ConvertValueView`4.ParentValueToViewValue">
            <summary>
            A function that converts a value of the wrapped matrix into a value of the wrapping matrix.
            </summary>
        </member>
        <member name="P:Bio.Matrix.ConvertValueView`4.ViewValueToParentValue">
            <summary>
            A function that converts value of the wrapped matrix into a value of the wrapped matrix.
            </summary>
        </member>
        <member name="T:Bio.Matrix.DenseAnsi">
            <summary>
            A Matrix that presents values externally as a (16-bit) char and internally as a (8-bit) byte.
            For this class, the special Missing value must be '?'.
            </summary>
        </member>
        <member name="T:Bio.Matrix.DenseStructMatrix`2">
            <summary>
            An abstract class for implementing a Matrix class that stores its values internally as a struct
            and in a file as a fixed number of characters. It is the superclass of, for example, DenseAnsi.
            </summary>
            <typeparam name="TStore">The struct used to store a value internally. For example, for DenseAnsi this is (8-bit) byte.</typeparam>
            <typeparam name="TValue">The type of values exposed externally. For example, for DenseAnsi this is (16-bit) char.</typeparam>
        </member>
        <member name="M:Bio.Matrix.DenseStructMatrix`2.StoreListToString(System.Collections.Generic.List{`0})">
            <summary>
            Implementor can assume that there is one value for every colKey
            </summary>
        </member>
        <member name="F:Bio.Matrix.DenseStructMatrix`2.RowKeyToStoreList">
            <summary>
            The dictionary that maps rowKeys into the stored version of a row. For example, for DenseAnsi the store list is a List of bytes.
            </summary>
        </member>
        <member name="M:Bio.Matrix.DenseStructMatrix`2.Write(System.String,System.Threading.Tasks.ParallelOptions)">
            <summary>
            Writes the matrix to a file, creating a directory if needed.
            The first line is "var" TAB and then the tab-delimited col keys.
            Next is one line per row key. Each line is the row key TAB and then all the row's values with no delimiters.
            Delimiters are not needed because each value is represented with a fixed number of characters.
            Values may include the fixed-number-of-characters version of the special Missing value.
            </summary>
            <param name="denseStructFileName">The name of the file to write to.</param>
            <param name="parallelOptions">Options for controlling any parallelism.</param>
        </member>
        <member name="M:Bio.Matrix.DenseStructMatrix`2.Write(System.IO.TextWriter,System.Threading.Tasks.ParallelOptions)">
            <summary>
            Writes the matrix to textWriter.
            The first line is "var" TAB and then the tab-delimited col keys.
            Next is one line per row key. Each line is the row key TAB and then all the row's values with no delimiters.
            Delimiters are not needed because each value is represented with a fixed number of characters.
            Values may include the fixed-number-of-characters version of the special Missing value.
            </summary>
            <param name="textWriter">The textWriter to write to.</param>
            <param name="parallelOptions">Options for controlling any parallelism.</param>
        </member>
        <member name="M:Bio.Matrix.DenseStructMatrix`2.RowKeysInFile(System.String)">
            <summary>
            From a file denseStruct format (for example, DenseAnsi format), returns a sequence of
            the rowKeys. This method scans the file on disk, making it more efficient than first loading it into memory.
            </summary>
            <param name="denseStructFileName">The name of a file in denseStruct format</param>
            <returns>A sequence of rowKeys.</returns>
        </member>
        <member name="M:Bio.Matrix.DenseStructMatrix`2.ColKeysInFile(System.String)">
            <summary>
            From a file denseStruct format (for example, DenseAnsi format), returns a sequence of
            the colKeys. This method scans the file on disk, making it more efficient than first loading it into memory.
            </summary>
            <param name="denseStructFileName">The name of a file in denseStruct format</param>
            <returns>A sequence of colKeys.</returns>
        </member>
        <member name="M:Bio.Matrix.DenseStructMatrix`2.GetInstanceFromSparseInternal(System.Collections.Generic.IEnumerable{Bio.Matrix.RowKeyColKeyValue{System.String,System.String,`1}})">
            <summary>
            Create a DenseStructMatrix from a sequences of RowKeyColKeyValue triples.
            </summary>
            <param name="tripleEnumerable">The squences of RowKeyColKeyValue triples</param>
        </member>
        <member name="T:Bio.Matrix.DenseStructMatrix`2.StaticStringToStoreListDelegate">
            <summary>
            The type of functions that can convert a string of a row's value (with no delimiters from a denseStruct file)
            to a list of the structs used to represent those values internally.
            Raises an exception if the line is the wrong length.
            </summary>
            <param name="line">The rows values represented as a string with no delimiters.</param>
            <param name="colCount">The number of colKeys.</param>
            <returns>The list of structed used to represent the values internally.</returns>
        </member>
        <member name="T:Bio.Matrix.DenseStructMatrix`2.StoreListToStringDelegate">
            <summary>
            The type of functions that can convert a list of structs (the internal represenation of a row's values) to
            a string of the values without delimiters, suitable to writing to a denseStruct file.
            </summary>
            <param name="storeList">A list of structs used to internally represent the values of a row.</param>
            <param name="colCount">ColCount</param>
            <returns></returns>
        </member>
        <member name="F:Bio.Matrix.DenseAnsi.StaticMissingValue">
            <summary>
            Always '?'
            </summary>
        </member>
        <member name="F:Bio.Matrix.DenseAnsi.StaticStoreMissingValue">
            <summary>
            Always (byte)'?'
            </summary>
        </member>
        <member name="M:Bio.Matrix.DenseAnsi.CreateEmptyInstance(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Char)">
            <summary>
            Creates an DenseAnsi with values missing.
            </summary>
            <param name="rowKeySequence">A sequence of row keys. The items will become the RowKeys of the Matrix.</param>
            <param name="colKeySequence">A sequence of colKeys. The items will come the ColKeys of the Matrix.</param>
            <param name="missingValue">The special Missing value, which must be '?'</param>
            <returns>A new, empty, DenseAnsi</returns>
        </member>
        <member name="M:Bio.Matrix.DenseAnsi.TryGetInstanceFromSparse(System.String,Bio.Matrix.Matrix{System.String,System.String,System.Char}@)">
            <summary>
            Creates a Matrix, internally in DenseAnsi format, from file(s) in sparse format.
            </summary>
            <param name="inputSparsePattern">The name of a file (or a pattern matching several files). The file(s) are in sparse format.</param>
            <param name="matrix">The new matrix, or null if the method fails.</param>
            <returns>true if the file(s) is read and the Matrix is created; otherwise, false </returns>
        </member>
        <member name="M:Bio.Matrix.DenseAnsi.TryGetInstanceFromSparse(System.String,Bio.Matrix.DenseAnsi@)">
            <summary>
            Creates a DenseAnsi from file(s) in sparse format.
            </summary>
            <param name="inputSparsePattern">The name of a file (or a pattern matching several files). The file(s) are in sparse format.</param>
            <param name="denseAnsi">The new DenseAnsi (or null, if the method fails).</param>
            <returns>true if the file(s) is read and the DenseAnsi is created; otherwise, false </returns>
        </member>
        <member name="M:Bio.Matrix.DenseAnsi.TryParseDenseAnsiFormatAsDoubleMatrix(System.String,System.Double,System.Threading.Tasks.ParallelOptions,Bio.Matrix.Matrix{System.String,System.String,System.Double}@)">
            <summary>
            Parse a file in DenseAnsi format such that the values are returned as doubles.
            </summary>
            <param name="filename">The file to parse</param>
            <param name="missingValue">The special value that represents missing</param>
            <param name="parallelOptions">A ParallelOptions instance that configures the multithreaded behavior of this operation.</param>
            <param name="matrix">The matrix created from parsing the file</param>
            <returns>True if the file can be parsed; false, otherwise.</returns>
        </member>
        <member name="M:Bio.Matrix.DenseAnsi.TryParseDenseAnsiFormatAsGenericMatrix``1(System.String,``0,System.Threading.Tasks.ParallelOptions,Bio.Matrix.Matrix{System.String,System.String,``0}@)">
            <summary>
            Tries to read a file in DenseAnsi format and then creates a DenseAnsi class with values of the desired type.
            </summary>
            <typeparam name="TValue">The type of values wanted, for example, double</typeparam>
            <param name="filename">The dense ansi formatted file to read from.</param>
            <param name="missingValue">The special value that represents missing</param>
            <param name="parallelOptions">A ParallelOptions instance that configures the multithreaded behavior of this operation.</param>
            <param name="matrix">A matrix that internally stores values in a DenseAnsi object.</param>
            <returns>true, if the file can be parsed; false, otherwise.</returns>
        </member>
        <member name="M:Bio.Matrix.DenseAnsi.GetInstanceFromSparse(System.String)">
            <summary>
            Creates a DenseAnsi from file(s) in sparse format. Throws an exception if the class cannot be created.
            </summary>
            <param name="inputSparsePattern">The name of a file (or a pattern matching several files). The file(s) are in sparse format.</param>
            <returns>The new DenseAnsi.</returns>
        </member>
        <member name="M:Bio.Matrix.DenseAnsi.TryGetInstance(System.String,System.Char,System.Threading.Tasks.ParallelOptions,Bio.Matrix.Matrix{System.String,System.String,System.Char}@)">
            <summary>
            This awkward method is provided for the sake of MatrixFactory. Right now it simply catches exceptions. Should switch and make it fail silently when doesn't work.
            </summary>
        </member>
        <member name="M:Bio.Matrix.DenseAnsi.GetInstance(System.String,System.Threading.Tasks.ParallelOptions)">
            <summary>
            Creates a DenseAnsi object from a file in dense ansi format.
            </summary>
            <param name="denseAnsiFileName">a file in dense ansi format</param>
            <param name="parallelOptions">A ParallelOptions instance that configures the multithreaded behavior of this operation.</param>
            <returns>the DenseAnsi object</returns>
        </member>
        <member name="M:Bio.Matrix.DenseAnsi.GetInstanceFromSparse(System.Collections.Generic.IEnumerable{Bio.Matrix.RowKeyColKeyValue{System.String,System.String,System.Char}})">
            <summary>
            Create a DenseAnsi object from a sequence of RowKeyColKeyValue triples.
            </summary>
            <param name="tripleEnumerable">a sequence of RowKeyColKeyValue</param>
            <returns>A DenseAnsi object</returns>
        </member>
        <member name="M:Bio.Matrix.DenseAnsi.WriteDenseAnsi(System.String,System.Threading.Tasks.ParallelOptions)">
            <summary>
            Write this DenseAnsi matrix to file.
            </summary>
            <param name="filename">The file to write to.</param>
            <param name="parallelOptions">A ParallelOptions instance that configures the multithreaded behavior of this operation.</param>
        </member>
        <member name="M:Bio.Matrix.DenseAnsi.WriteDenseAnsi(System.IO.TextWriter,System.Threading.Tasks.ParallelOptions,System.Boolean)">
            <summary>
            Write this DenseAnsi matrix to a textWriter
            </summary>
            <param name="textWriter"></param>
            <param name="parallelOptions">A ParallelOptions instance that configures the multithreaded behavior of this operation.</param>
            <param name="verbose">ignored</param>
        </member>
        <member name="P:Bio.Matrix.DenseAnsi.MissingValue">
            <summary>
            Always '?'
            </summary>
        </member>
        <member name="T:Bio.Matrix.DenseAnsiExtensions">
            <summary>
            Extension methods on Matrix related to DenseAnsi.
            </summary>
        </member>
        <member name="M:Bio.Matrix.DenseAnsiExtensions.AsDenseAnsi(Bio.Matrix.Matrix{System.String,System.String,System.Char},System.Threading.Tasks.ParallelOptions)">
            <summary>
            Converts matrix to a DenseAnsi. If matrix is already a DenseAnsi, then returns the given matrix without copying. 
            </summary>
            <param name="inputMatrix">The matrix to convert from</param>
            <param name="parallelOptions">A ParallelOptions instance that configures the multithreaded behavior of this operation.</param>
            <returns>A denseAnsi version of the matrix</returns>
        </member>
        <member name="M:Bio.Matrix.DenseAnsiExtensions.ToDenseAnsi(Bio.Matrix.Matrix{System.String,System.String,System.Char},System.Threading.Tasks.ParallelOptions)">
            <summary>
            Converts matrix to a DenseAnsi. Even if the matrix is already an denseAnsi, a new one is created.. 
            </summary>
            <param name="matrix">The matrix to convert from</param>
            <param name="parallelOptions">A ParallelOptions instance that configures the multithreaded behavior of this operation.</param>
            <returns>A denseAnsi version of the matrix</returns>
        </member>
        <member name="M:Bio.Matrix.DenseAnsiExtensions.AsDenseAnsi``1(Bio.Matrix.Matrix{System.String,System.String,``0},System.Threading.Tasks.ParallelOptions)">
            <summary>
            Converts matrix to a DenseAnsi. If matrix is already a dense collection, then returns the given matrix without copying. 
            </summary>
            <param name="inputMatrix">The matrix to convert from</param>
            <param name="parallelOptions">A ParallelOptions instance that configures the multithreaded behavior of this operation.</param>
            <returns>A denseAnsi version of the matrix</returns>
        </member>
        <member name="M:Bio.Matrix.DenseAnsiExtensions.ToDenseAnsi``1(Bio.Matrix.Matrix{System.String,System.String,``0},System.Threading.Tasks.ParallelOptions)">
            <summary>
            Converts matrix to a DenseAnsi. Even if the matrix is already an denseAnsi, a new one is created.. 
            </summary>
            <param name="matrix">The matrix to convert from</param>
            <param name="parallelOptions">A ParallelOptions instance that configures the multithreaded behavior of this operation.</param>
            <returns>A denseAnsi version of the matrix</returns>
        </member>
        <member name="M:Bio.Matrix.DenseAnsiExtensions.WriteDenseAnsi``1(Bio.Matrix.Matrix{System.String,System.String,``0},System.String,System.Threading.Tasks.ParallelOptions)">
            <summary>
            Writes a matrix in DenseAnsi format to a file. Converts the values of the matrix to char (on the fly). Does not need to convert to DenseAnsi format.
            </summary>
            <typeparam name="T">The type of the values of the matrix, for example, double</typeparam>
            <param name="matrix">The matrix to write</param>
            <param name="filename">The file to write to</param>
            <param name="parallelOptions">A ParallelOptions instance that configures the multithreaded behavior of this operation.</param>
        </member>
        <member name="M:Bio.Matrix.DenseAnsiExtensions.WriteDenseAnsi``1(Bio.Matrix.Matrix{System.String,System.String,``0},System.IO.TextWriter,System.Threading.Tasks.ParallelOptions,System.Boolean)">
            <summary>
            Writes a matrix in DenseAnsi format to a textWriter. Converts the values of the matrix to char (on the fly). Does not need to convert to DenseAnsi format.
            </summary>
            <typeparam name="T">The type of the values of the matrix, for example, double</typeparam>
            <param name="matrix">The matrix to write</param>
            <param name="textWriter">The stream to write to</param>
            <param name="parallelOptions">A ParallelOptions instance that configures the multithreaded behavior of this operation.</param>
            <param name="verbose">If true, may write out messages to the console telling how far along the writing is.</param>
        </member>
        <member name="M:Bio.Matrix.DenseAnsiExtensions.WriteDenseAnsi(Bio.Matrix.Matrix{System.String,System.String,System.Char},System.IO.TextWriter,System.Threading.Tasks.ParallelOptions,System.Boolean)">
            <summary>
            Writes a matrix with char values in DenseAnsi format to a textWriter. Does not need to convert to DenseAnsi format.
            </summary>
            <param name="matrix">The matrix to write</param>
            <param name="textWriter">The stream to write to</param>
            <param name="parallelOptions">A ParallelOptions instance that configures the multithreaded behavior of this operation.</param>
            <param name="verbose">If true, may write out messages to the console telling how far along the writing is.</param>
        </member>
        <member name="T:Bio.Matrix.DenseMatrix`3">
            <summary>
            A Matrix that stores the values internally in a .NET 2-D array.
            </summary>
            <typeparam name="TRowKey">The type of the row key. Usually "String"</typeparam>
            <typeparam name="TColKey">The type of the col key. Usually "String"</typeparam>
            <typeparam name="TValue">The type of the value, for example, double, int, char, etc.</typeparam>
        </member>
        <member name="M:Bio.Matrix.DenseMatrix`3.#ctor(`2[0:,0:]@,System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`1},`2)">
            <summary>
            Initializes a new instance of the DenseMatrix class that wraps a .NET 2-D array
            </summary>
            <param name="valueArray">The 2-D .NET array to wrap.</param>
            <param name="rowKeySequence">A sequence of row keys. The items will become the RowKeys of the Matrix.</param>
            <param name="colKeySequence">A sequence of colKeys. The items will come the ColKeys of the Matrix.</param>
            <param name="missingValue">The special value that represents missing.</param>
        </member>
        <member name="M:Bio.Matrix.DenseMatrix`3.#ctor(`2[0:,0:],System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`1},`2)">
            <summary>
            Initializes a new instance of the DenseMatrix class that wraps a .NET 2-D array
            </summary>
            <param name="valueArray">The 2-D .NET array to wrap.</param>
            <param name="rowKeySequence">A sequence of row keys. The items will become the RowKeys of the Matrix.</param>
            <param name="colKeySequence">A sequence of colKeys. The items will come the ColKeys of the Matrix.</param>
            <param name="missingValue">The special value that represents missing.</param>
        </member>
        <member name="F:Bio.Matrix.DenseMatrix`3.ValueArray">
            <summary>
            The 2-D .NET array used to store values.
            </summary>
        </member>
        <member name="M:Bio.Matrix.DenseMatrix`3.TryParseRFileWithDefaultMissing(System.String,`2,System.Threading.Tasks.ParallelOptions,Bio.Matrix.Matrix{`0,`1,`2}@)">
            <summary>
            Create a DenseMatrix from a file in RFile format.
            </summary>
            <param name="rFileName">a file in RFile format</param>
            <param name="missingValue">The special value that represents 'missing'</param>
            <param name="parallelOptions">A ParallelOptions instance that configures the multithreaded behavior of this operation.</param>
            <param name="matrix">The DenseMatrix created</param>
            <returns>True if the file is parsable; otherwise false</returns>
        </member>
        <member name="M:Bio.Matrix.DenseMatrix`3.TryParseTabbedRFileWithDefaultMissing(System.String,`2,System.Threading.Tasks.ParallelOptions,Bio.Matrix.Matrix{`0,`1,`2}@)">
            <summary>
            Create a DenseMatrix from a file in RFile format.
            </summary>
            <param name="rFileName">a file in RFile format with tab delimited columns</param>
            <param name="missingValue">The special value that represents 'missing'</param>
            <param name="parallelOptions">A ParallelOptions instance that configures the multithreaded behavior of this operation.</param>
            <param name="matrix">The DenseMatrix created</param>
            <returns>True if the file is parsable; otherwise false</returns>
        </member>
        <member name="M:Bio.Matrix.DenseMatrix`3.TryParseRFileWithDefaultMissing(System.String,`2,System.Threading.Tasks.ParallelOptions,Bio.Matrix.Matrix{`0,`1,`2}@,System.String@)">
            <summary>
            Create a DenseMatrix from a file in RFile format.
            </summary>
            <param name="rFileName">a file in RFile format with space or tab delimited columns</param>
            <param name="missingValue">The special value that represents 'missing'</param>
            <param name="parallelOptions">A ParallelOptions instance that configures the multithreaded behavior of this operation.</param>
            <param name="matrix">The DenseMatrix created</param>
            <param name="errorMsg">If the file is not parsable, an error message about the problem.</param>
            <returns>True if the file is parsable; otherwise false</returns>
        </member>
        <member name="M:Bio.Matrix.DenseMatrix`3.TryParseTabbedRFileWithDefaultMissing(System.String,`2,System.Threading.Tasks.ParallelOptions,Bio.Matrix.Matrix{`0,`1,`2}@,System.String@)">
            <summary>
            Create a DenseMatrix from a file in RFile format.
            </summary>
            <param name="rFileName">a file in RFile format with tab delimited columns</param>
            <param name="missingValue">The special value that represents 'missing'</param>
            <param name="parallelOptions">A ParallelOptions instance that configures the multithreaded behavior of this operation.</param>
            <param name="result">The DenseMatrix created</param>
            <param name="errorMsg">If the file is not parsable, an error message about the problem.</param>
            <returns>True if the file is parsable; otherwise false</returns>
        </member>
        <member name="M:Bio.Matrix.DenseMatrix`3.TryParseRFileWithDefaultMissing(System.String,`2,System.Char[],System.Threading.Tasks.ParallelOptions,Bio.Matrix.Matrix{`0,`1,`2}@,System.String@)">
            <summary>
            Create a DenseMatrix from a file in RFile format.
            </summary>
            <param name="rFileName">a file in RFile format with delimited columns</param>
            <param name="missingValue">The special value that represents 'missing'</param>
            <param name="separatorArray">An array of character delimiters</param>
            <param name="parallelOptions">A ParallelOptions instance that configures the multithreaded behavior of this operation.</param>
            <param name="result">The DenseMatrix created</param>
            <param name="errorMsg">If the file is not parsable, an error message about the problem.</param>
            <returns>True if the file is parsable; otherwise false</returns>
        </member>
        <member name="M:Bio.Matrix.DenseMatrix`3.TryParseRFileWithDefaultMissing(Bio.IO.INamedStreamCreator,`2,System.Char[],System.Threading.Tasks.ParallelOptions,Bio.Matrix.Matrix{`0,`1,`2}@,System.String@)">
            <summary>
            Create a DenseMatrix from a file in RFile format.
            </summary>
            <param name="namedStreamCreator">a namedStreamCreator with delimited columns</param>
            <param name="missingValue">The special value that represents 'missing'</param>
            <param name="separatorArray">An array of character delimiters</param>
            <param name="parallelOptions">A ParallelOptions instance that configures the multithreaded behavior of this operation.</param>
            <param name="result">The DenseMatrix created</param>
            <param name="errorMsg">If the file is not parsable, an error message about the problem.</param>
            <returns>True if the file is parsable; otherwise false</returns>
        </member>
        <member name="M:Bio.Matrix.DenseMatrix`3.CreateDefaultInstance(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`1},`2)">
            <summary>
            Initalizes a new instance of the DenseMatrix class filled with the default value of TValue. For example, if TValue is double,
            the matrix will be filled with 0.0's.
            </summary>
            <param name="rowKeySequence">A sequence of row keys. The items will become the RowKeys of the Matrix.</param>
            <param name="colKeySequence">A sequence of colKeys. The items will come the ColKeys of the Matrix.</param>
            <param name="missingValue">The special Missing value.</param>
            <returns>A new instance of DenseMatrix</returns>
        </member>
        <member name="T:Bio.Matrix.DensePairAnsi">
            <summary>
            A Matrix that presents values externally as two sorted (16-bit) chars and internally as two bytes.
            For this class, the special Missing value must be the pair '?','?'.
            </summary>
        </member>
        <member name="F:Bio.Matrix.DensePairAnsi.StaticMissingValue">
            <summary>
            For DensePairAnsi the missing value is always the same: ?,?. This is a static version of that missing value.
            </summary>
        </member>
        <member name="F:Bio.Matrix.DensePairAnsi.StaticStoreMissingValue">
            <summary>
            For DensePairAnsi the missing value is always the same: ?,?. This is a static version of that missing value.
            </summary>
        </member>
        <member name="M:Bio.Matrix.DensePairAnsi.CreateEmptyInstance(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},Bio.Util.UOPair{System.Char})">
            <summary>
            Creates an DensePairAnsi with values missing.
            </summary>
            <param name="rowKeySequence">A sequence of row keys. The items will become the RowKeys of the Matrix.</param>
            <param name="colKeySequence">A sequence of colKeys. The items will come the ColKeys of the Matrix.</param>
            <param name="missingValue">The special Missing value, which must be (UO '?','?')</param>
            <returns>A new, empty, DensePairAnsi</returns>
        </member>
        <member name="M:Bio.Matrix.DensePairAnsi.GetInstanceFromSparse(System.String)">
            <summary>
            Parses directly from the SparseFile format. Useful if memory must be concerved.
            </summary>
            <param name="inputSparseFileName">Name of a file in Sparse format.</param>
            <returns>An instance of DensePairAnsi.</returns>
        </member>
        <member name="M:Bio.Matrix.DensePairAnsi.GetInstanceFromSparse(System.Collections.Generic.IEnumerable{Bio.Matrix.RowKeyColKeyValue{System.String,System.String,Bio.Util.UOPair{System.Char}}})">
            <summary>
            Create a DensePairAnsi object from a sequence of RowKeyColKeyValue triples.
            </summary>
            <param name="tripleEnumerable">a sequence of RowKeyColKeyValue</param>
            <returns>A DensePairAnsi object</returns>
        </member>
        <member name="M:Bio.Matrix.DensePairAnsi.GetInstance(System.Collections.Generic.IEnumerable{System.Linq.IGrouping{System.String,System.Collections.Generic.KeyValuePair{System.String,Bio.Util.UOPair{System.Char}}}})">
            <summary>
            Creates a DensePairAnsi object from a sequence of groupings. A grouping here is a row 
            </summary>
            <param name="snpGroupsCidToNucPairEnumerable"></param>
            <returns></returns>
        </member>
        <member name="M:Bio.Matrix.DensePairAnsi.GetInstance(System.String,System.Threading.Tasks.ParallelOptions)">
            <summary>
            Creates a DensePairAnsi object from a file in dense pair ansi format.
            </summary>
            <param name="densePairAnsiFileName">a file in dense pair ansi format</param>
            <param name="parallelOptions">A ParallelOptions instance that configures the multithreaded behavior of this operation.</param>
            <returns>the DensePairAnsi object</returns>
        </member>
        <member name="T:Bio.Matrix.DensePairAnsiExtensions">
            <summary>
            Extension methods on Matrix related to DensePairAnsi.
            </summary>
        </member>
        <member name="M:Bio.Matrix.DensePairAnsiExtensions.AsDensePairAnsi(Bio.Matrix.Matrix{System.String,System.String,Bio.Util.UOPair{System.Char}},System.Threading.Tasks.ParallelOptions)">
            <summary>
            Converts matrix to a DensePairAnsi. If matrix is already a DensePairAnsi, then returns the given matrix without copying. 
            </summary>
            <param name="inputMatrix">The matrix to convert from</param>
            <param name="parallelOptions">Options for controlling any parallelism.</param>
            <returns>A densePairAnsi version of the matrix</returns>
        </member>
        <member name="M:Bio.Matrix.DensePairAnsiExtensions.ToDensePairAnsi(Bio.Matrix.Matrix{System.String,System.String,Bio.Util.UOPair{System.Char}},System.Threading.Tasks.ParallelOptions)">
            <summary>
            Converts matrix to a DensePairAnsi. Even if the matrix is already an densePairAnsi, a new one is created.. 
            </summary>
            <param name="matrix">The matrix to convert from</param>
            <param name="parallelOptions">Options for controlling any parallelism.</param>
            <returns>A densePairAnsi version of the matrix</returns>
        </member>
        <member name="M:Bio.Matrix.DensePairAnsiExtensions.WriteDensePairAnsi(Bio.Matrix.Matrix{System.String,System.String,Bio.Util.UOPair{System.Char}},System.String,System.Threading.Tasks.ParallelOptions)">
            <summary>
            Write a matrix to DensePairAnsi file format.
            </summary>
            <param name="matrix">The matrix to write</param>
            <param name="filename">The file to write to</param>
            <param name="parallelOptions">A ParallelOptions instance that configures the multithreaded behavior of this operation.</param>
        </member>
        <member name="M:Bio.Matrix.DensePairAnsiExtensions.WriteDensePairAnsi(Bio.Matrix.Matrix{System.String,System.String,Bio.Util.UOPair{System.Char}},System.IO.TextWriter,System.Threading.Tasks.ParallelOptions)">
            <summary>
            Write a matrix to DensePairAnsi file format
            </summary>
            <param name="matrix">The matrix to write</param>
            <param name="textWriter">The TextWriter to write to</param>
            <param name="parallelOptions">A ParallelOptions instance that configures the multithreaded behavior of this operation.</param>
        </member>
        <member name="T:Bio.Matrix.HashableView`3">
            <summary>
            A wrapper around a parent matrix that allows a matrix to be hashed. This, for example, allows a matrix to be
            used as the key of a dictionary. Two matricies will hash together if they are MatrixEqual.
            
            Every time it needs to confirm that two matrices really are equal, it will call MatrixEqual which
            can require a scan of every value.
            
            The wrapper doesn't allow it's values to be changed. Any changes in the values of its parent matrix will *not* be
            reflected in its hashcode and so can give unexpected results.
            </summary>
            <typeparam name="TRowKey">The type of the row key. Usually "String"</typeparam>
            <typeparam name="TColKey">The type of the col key. Usually "String"</typeparam>
            <typeparam name="TValue">The type of the value, for example, double, int, char, etc.</typeparam>
        </member>
        <member name="M:Bio.Matrix.HashableView`3.Remove(`0,`1)">
            <summary>
            The wrapper doesn't allow its values to be changed. This method throws an exception.
            </summary>
            <param name="rowKey">The key for the row of interest. The key must exist in RowKeys (and, thus, IndexOfRowKey)</param>
            <param name="colKey">The key for the col of interest. The key must exist in ColKeys (and, thus, IndexOfColKey)</param>
            <returns>This method throws an exception.</returns>
        </member>
        <member name="M:Bio.Matrix.HashableView`3.SetValueOrMissing(System.Int32,System.Int32,`2)">
            <summary>
            The wrapper doesn't allow its values to be changed. This method throws an exception.
            </summary>
            <param name="rowIndex">The index for the row of interest</param>
            <param name="colIndex">The index for the col of interest</param>
            <param name="value">The value to set</param>
            <returns>This method throws an exception.</returns>
        </member>
        <member name="M:Bio.Matrix.HashableView`3.SetValueOrMissing(`0,`1,`2)">
            <summary>
            The wrapper doesn't allow its values to be changed. This method throws an exception.
            </summary>
            <param name="rowKey">The key for the row of interest. The key must exist in RowKeys (and, thus, IndexOfRowKey)</param>
            <param name="colKey">The key for the col of interest. The key must exist in ColKeys (and, thus, IndexOfColKey)</param>
            <param name="value">Value that will be set.</param>
            <returns>This method throws an exception.</returns>
        </member>
        <member name="M:Bio.Matrix.HashableView`3.GetHashCode">
            <summary>
            Returns the hashcode of the matrix. This values is computed only once from when the HashableView is constructed.
            Two matricies will hash together if they are MatrixEqual.
            
            Every time the class needs to confirm that two matrices really are equal, it will call Equals which calls MatrixEqual which
            can require a scan of every value.
            </summary>
            <returns>a hashcode based on rowKeys, colKeys, special missing value, and values of the matrix.</returns>
        </member>
        <member name="M:Bio.Matrix.HashableView`3.Equals(System.Object)">
            <summary>
            Two HashableView matrices are equal if they are MatrixEquals, that is, they have the same
            RowKeys and ColKeys (in the same order), the same special MissingValue, and the same values.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="P:Bio.Matrix.HashableView`3.ParentMatrix">
            <summary>
            The matrix that this view wraps.
            </summary>
        </member>
        <member name="T:Bio.Matrix.RowKeyColKeyValue`3">
            <summary>
            A structure for representing the triple of rowKey, colKey, and value.
            </summary>
            <typeparam name="TRowKey">The type of the row key. Usually "String"</typeparam>
            <typeparam name="TColKey">The type of the col key. Usually "String"</typeparam>
            <typeparam name="TValue">The type of the value, for example, double, int, char, etc.</typeparam>
        </member>
        <member name="M:Bio.Matrix.RowKeyColKeyValue`3.#ctor(`0,`1,`2)">
            <summary>
            Initializes a new instance of the RowKeyColKeyValue structure with the specified keys and value.
            </summary>
            <param name="rowKey">The key for the row of interest.</param>
            <param name="colKey">The key for the col of interest.</param>
            <param name="value">The value associated with these keys.</param>
        </member>
        <member name="F:Bio.Matrix.RowKeyColKeyValue`3.RowKey">
            <summary>
            The rowKey in the triple.
            </summary>
        </member>
        <member name="F:Bio.Matrix.RowKeyColKeyValue`3.ColKey">
            <summary>
            The colKey in the triple.
            </summary>
        </member>
        <member name="F:Bio.Matrix.RowKeyColKeyValue`3.Value">
            <summary>
            The value in the triple.
            </summary>
        </member>
        <member name="M:Bio.Matrix.RowKeyColKeyValue`3.ToString">
            <summary>
            Returns a string represenation of the RowKeyColKeyValue, using the string represenations of the keys and of the value.
            </summary>
            <returns>A string representation of the RowKeyColKeyValue, which includes the string representations of the keys and value.</returns>
        </member>
        <member name="T:Bio.Matrix.RowKeyColKeyValue">
            <summary>
            Defines a static Create method.
            </summary>
        </member>
        <member name="M:Bio.Matrix.RowKeyColKeyValue.Create``3(``0,``1,``2)">
            <summary>
            Usage:  RowKeyColKeyValue.Create(rowKey, colKey, value)
            </summary>
        </member>
        <member name="T:Bio.Matrix.MatrixFactoryDelegate`4">
            <summary>
            The type of functions that can create new Matrix objects. Because values are not specified, the resulting matrix
            is typically empty or full of default values.
            </summary>
            <typeparam name="TMatrix">The type of matrix created. Must be a subclass Matrix{TRowKey,TColKey,TValue}.</typeparam>
            <typeparam name="TRowKey">The type of the row key. Usually "String"</typeparam>
            <typeparam name="TColKey">The type of the col key. Usually "String"</typeparam>
            <typeparam name="TValue">The type of the value, for example, double, int, char, etc.</typeparam>
            <param name="rowKeySequence">A sequence of row keys. The items will become the RowKeys of the Matrix.</param>
            <param name="colKeySequence">A sequence of colKeys. The items will come the ColKeys of the Matrix.</param>
            <param name="missingValue">The special Missing value.</param>
            <returns>A new matrix.</returns>
        </member>
        <member name="T:Bio.Matrix.MatrixFormatException">
            <summary>
            The exception that is thrown when the parsing of data into a Matrix fails.
            </summary>
        </member>
        <member name="M:Bio.Matrix.MatrixFormatException.#ctor">
            <summary>
                Initializes a new instance of the MatrixFormatException class.
            </summary>
        </member>
        <member name="M:Bio.Matrix.MatrixFormatException.#ctor(System.String)">
            <summary>
                Initializes a new instance of the System.FormatException class with a specified
                error message.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:Bio.Matrix.MatrixFormatException.#ctor(System.String,System.Exception)">
            <summary>
            Set the exception string with the innerException.
            </summary>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="M:Bio.Matrix.MatrixFormatException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
                Initializes a new instance of the System.SystemException class with serialized data.
            </summary>
            <param name="info">The object that holds the serialized object data.</param>
            <param name="context">The contextual information about the source or destination.</param>
        </member>
        <member name="T:Bio.Matrix.MatrixExtensions">
            <summary>
            Provides a set of static methods for Matrix objects.
            </summary>
        </member>
        <member name="M:Bio.Matrix.MatrixExtensions.AsDenseMatrix``3(Bio.Matrix.Matrix{``0,``1,``2})">
            <summary>
            Converts matrix to a DenseMatrix. If the inputMatrix is a DenseMatrix, then returns the given matrix without copying. The copy could, therefore,
            be either shallow or deep.
            </summary>
            <typeparam name="TRowKey">The type of the row key. Usually "String"</typeparam>
            <typeparam name="TColKey">The type of the col key. Usually "String"</typeparam>
            <typeparam name="TValue">The type of the value, for example, double, int, char, etc.</typeparam>
            <param name="inputMatrix">The matrix to convert.</param>
            <returns>A DenseMatrix with same rowKeys, colKeys, missing and nonmissing values, and special missing value. If the inputMatrix is a DenseMatrix, then it will be returned unchanged.</returns>
        </member>
        <member name="M:Bio.Matrix.MatrixExtensions.ToDenseMatrix``3(Bio.Matrix.Matrix{``0,``1,``2})">
            <summary>
            Converts matrix to a new DenseMatrix. Even if the inputMatrix is a DenseMatrix, a new DenseMatrix is created. The copy is, thus,
            always deep if TValue is an atomic type.
            </summary>
            <typeparam name="TRowKey">The type of the row key. Usually "String"</typeparam>
            <typeparam name="TColKey">The type of the col key. Usually "String"</typeparam>
            <typeparam name="TValue">The type of the value, for example, double, int, char, etc.</typeparam>
            <param name="inputMatrix">The matrix to convert.</param>
            <returns>A new DenseMatrix with same rowKeys, colKeys, missing and nonmissing values, and special missing value.</returns>
        </member>
        <member name="M:Bio.Matrix.MatrixExtensions.WriteDense``3(Bio.Matrix.Matrix{``0,``1,``2},System.String)">
            <summary>
            Writes the matrix to a file in dense format. A directory will be created if needed.
            The first line is "var" TAB and then the tab-delimited col keys.
            Next is one line per row key. Each line is the row key TAB and then the tab-limited values.
            Values may include the special Missing value.
            </summary>
            <typeparam name="TRowKey">The type of the row key. Usually "String"</typeparam>
            <typeparam name="TColKey">The type of the col key. Usually "String"</typeparam>
            <typeparam name="TValue">The type of the value, for example, double, int, char, etc.</typeparam>
            <param name="matrix">The matrix to write</param>
            <param name="filename">The filename to write to.</param>
        </member>
        <member name="M:Bio.Matrix.MatrixExtensions.WriteSparse``3(Bio.Matrix.Matrix{``0,``1,``2},System.String)">
            <summary>
            Writes the matrix to a file in sparse format. A directory will be created if needed.
            The first line is "var" TAB "cid" TAB "val"
            Next is one line per nonmissing value. Each line is: rowKey TAB colKey TAB value
            </summary>
            <typeparam name="TRowKey">The type of the row key. Usually "String"</typeparam>
            <typeparam name="TColKey">The type of the col key. Usually "String"</typeparam>
            <typeparam name="TValue">The type of the value, for example, double, int, char, etc.</typeparam>
            <param name="matrix">The matrix to write</param>
            <param name="filename">The filename to write to.</param>
        </member>
        <member name="M:Bio.Matrix.MatrixExtensions.WriteSparse``3(Bio.Matrix.Matrix{``0,``1,``2},System.IO.TextWriter)">
            <summary>
            Writes the matrix to textWriter in sparse format.
            The first line is "var" TAB "cid" TAB "val"
            Next is one line per nonmissing value. Each line is: rowKey TAB colKey TAB value
            </summary>
            <typeparam name="TRowKey">The type of the row key. Usually "String"</typeparam>
            <typeparam name="TColKey">The type of the col key. Usually "String"</typeparam>
            <typeparam name="TValue">The type of the value, for example, double, int, char, etc.</typeparam>
            <param name="matrix">The matrix to write</param>
            <param name="textWriter">The textWriter to write to.</param>
        </member>
        <member name="T:Bio.Matrix.TryParseMatrixDelegate`3">
            <summary>
            The type of functions that can create new Matrix objects from a file.
            </summary>
            <typeparam name="TRowKey">The type of the row key. Usually "String"</typeparam>
            <typeparam name="TColKey">The type of the col key. Usually "String"</typeparam>
            <typeparam name="TValue">The type of the value, for example, double, int, char, etc.</typeparam>
            <param name="filename">The name of the file containing the matrix information.</param>
            <param name="missingValue">The special value that represents missing in the created matrix.</param>
            <param name="parallelOptions">A ParallelOptions instance that configures the multithreaded behavior of this operation.</param>
            <param name="matrix">The matrix created.</param>
            <returns>true if the function was able to create a matrix from the information in the file; otherwise, false</returns>
        </member>
        <member name="T:Bio.Matrix.MatrixFactory`3">
            <summary>
            A class for creating a factory for parsing matrix files.
            </summary>
            <typeparam name="TRowKey">The type of the row key. Usually "String"</typeparam>
            <typeparam name="TColKey">The type of the col key. Usually "String"</typeparam>
            <typeparam name="TValue">The type of the value, for example, double, int, char, etc.</typeparam>
        </member>
        <member name="M:Bio.Matrix.MatrixFactory`3.#ctor">
            <summary>
            A parameterless constructor for the MatrixFactor.
            </summary>
        </member>
        <member name="M:Bio.Matrix.MatrixFactory`3.GetInstance">
            <summary>
            Initializes a new instance of a Matrix parse factory.
            </summary>
            <returns>A MatrixFactory that can be used to create a Matrix instance from a file.</returns>
        </member>
        <member name="M:Bio.Matrix.MatrixFactory`3.RegisterMatrixParser(Bio.Matrix.TryParseMatrixDelegate{`0,`1,`2})">
            <summary>
            Adds the specificed parsing function to the MatrixFactory
            </summary>
            <param name="tryParseMatrixDelegate">The function to add.</param>
        </member>
        <member name="M:Bio.Matrix.MatrixFactory`3.Parse(System.String,`2,System.Threading.Tasks.ParallelOptions)">
            <summary>
            Create a Matrix by parsing the file. The MatrixFactory may try many different parsers to get a result.
            </summary>
            <param name="filename">The name of the file containing the matrix information.</param>
            <param name="missingValue">The special value that represents missing in the created matrix.</param>
            <param name="parallelOptions">A ParallelOptions instance that configures the multithreaded behavior of this operation.</param>
            <returns>the Matrix created</returns>
        </member>
        <member name="M:Bio.Matrix.MatrixFactory`3.TryParse(System.String,`2,System.Threading.Tasks.ParallelOptions,Bio.Matrix.Matrix{`0,`1,`2}@)">
            <summary>
            Create a Matrix by parsing the file. The MatrixFactory may try many different parsers to get a result.
            </summary>
            <param name="filename">The name of the file containing the matrix information.</param>
            <param name="missingValue">The special value that represents missing in the created matrix.</param>
            <param name="parallelOptions">A ParallelOptions instance that configures the multithreaded behavior of this operation.</param>
            <param name="result">The matrix created.</param>
            <returns>true, if some parse succeeds; otherwise, false</returns>
        </member>
        <member name="P:Bio.Matrix.MatrixFactory`3.ErrorMessages">
            <summary>
            The last error messges
            </summary>
        </member>
        <member name="T:Bio.Matrix.MatrixViewExtensions">
            <summary>
            Provides a set of static methods for creating view on a Matrix. A view is a light-weight wrapper around a matrix such
            that value changes to either the matrix or its view(s) will be reflected in both.
            </summary>
        </member>
        <member name="M:Bio.Matrix.MatrixViewExtensions.SelectRowsAndColsView``3(Bio.Matrix.Matrix{``0,``1,``2},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
            <summary>
            Create a view of a parent matrix with a subset of the rows (perhaps in a different order) and
            a subset of the cols (perhaps in a different order). If the subsets happen to include all
            rows and cols in the same order, the parent matrix is returned.
            This is a 'view' in the sense that changes to the values in either matrix will be reflected in both.
            </summary>
            <typeparam name="TRowKey">The type of the row key. Usually "String"</typeparam>
            <typeparam name="TColKey">The type of the col key. Usually "String"</typeparam>
            <typeparam name="TValue">The type of the value, for example, double, int, char, etc.</typeparam>
            <param name="parentMatrix">The matrix to wrap.</param>
            <param name="rowKeySequence">A sequence of rowKeys that specifies the subset of rows to include and their desired order.</param>
            <param name="colKeySequence">A sequence of colKeys that specifies the subset of cols to include and their desired order.</param>
            <returns>A matrix with the desired rows and cols in their desired order.</returns>
        </member>
        <member name="M:Bio.Matrix.MatrixViewExtensions.SelectRowsView``3(Bio.Matrix.Matrix{``0,``1,``2},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Create a view of a parent matrix with a subset of the rows (perhaps in a different order).
            If the subset happens to include all rows in the same order, the parent matrix is returned.
            This is a 'view' in the sense that changes to the values in either matrix will be reflected in both.
            </summary>
            <typeparam name="TRowKey">The type of the row key. Usually "String"</typeparam>
            <typeparam name="TColKey">The type of the col key. Usually "String"</typeparam>
            <typeparam name="TValue">The type of the value, for example, double, int, char, etc.</typeparam>
            <param name="parentMatrix">The matrix to wrap.</param>
            <param name="rowKeySequence">A sequence of rowKeys that specifies the subset of rows to include and their desired order.</param>
            <returns>A matrix with the desired rows in their desired order.</returns>
        </member>
        <member name="M:Bio.Matrix.MatrixViewExtensions.SelectColsView``3(Bio.Matrix.Matrix{``0,``1,``2},System.Collections.Generic.IEnumerable{``1})">
            <summary>
            Create a view of a parent matrix with a subset of the cols (perhaps in a different order).
            If the subset happens to include all
            cols in the same order, the parent matrix is returned.
            This is a 'view' in the sense that changes to the values in either matrix will be reflected in both.
            </summary>
            <typeparam name="TRowKey">The type of the row key. Usually "String"</typeparam>
            <typeparam name="TColKey">The type of the col key. Usually "String"</typeparam>
            <typeparam name="TValue">The type of the value, for example, double, int, char, etc.</typeparam>
            <param name="parentMatrix">The matrix to wrap.</param>
            <param name="colKeySequence">A sequence of colKeys that specifies the subset of cols to include and their desired order.</param>
            <returns>A matrix with the desired cols in their desired order.</returns>
        </member>
        <member name="M:Bio.Matrix.MatrixViewExtensions.SelectRowsAndColsView``3(Bio.Matrix.Matrix{``0,``1,``2},System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Create a view of a parent matrix with a subset of the rows (perhaps in a different order) and
            a subset of the cols (perhaps in a different order). If the subsets happen to include all
            rows and cols in the same order, the parent matrix is returned.
            This is a 'view' in the sense that changes to the values in either matrix will be reflected in both.
            </summary>
            <typeparam name="TRowKey">The type of the row key. Usually "String"</typeparam>
            <typeparam name="TColKey">The type of the col key. Usually "String"</typeparam>
            <typeparam name="TValue">The type of the value, for example, double, int, char, etc.</typeparam>
            <param name="parentMatrix">The matrix to wrap.</param>
            <param name="rowIndexEnumerable">A sequence of row indexes that specifies the subset of rows to include and their desired order.</param>
            <param name="colIndexSequence">A sequence of col indexes that specifies the subset of cols to include and their desired order.</param>
            <returns>A matrix with the desired rows and cols in their desired order.</returns>
        </member>
        <member name="M:Bio.Matrix.MatrixViewExtensions.SelectRowsView``3(Bio.Matrix.Matrix{``0,``1,``2},System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Create a view of a parent matrix with a subset of the rows (perhaps in a different order).
            If the subsets happen to include all rows in the same order, the parent matrix is returned.
            This is a 'view' in the sense that changes to the values in either matrix will be reflected in both.
            </summary>
            <typeparam name="TRowKey">The type of the row key. Usually "String"</typeparam>
            <typeparam name="TColKey">The type of the col key. Usually "String"</typeparam>
            <typeparam name="TValue">The type of the value, for example, double, int, char, etc.</typeparam>
            <param name="parentMatrix">The matrix to wrap.</param>
            <param name="rowIndexEnumerable">A sequence of row indexes that specifies the subset of rows to include and their desired order.</param>
            <returns>A matrix with the desired rows and cols in their desired order.</returns>
        </member>
        <member name="M:Bio.Matrix.MatrixViewExtensions.SelectColsView``3(Bio.Matrix.Matrix{``0,``1,``2},System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Create a view of a parent matrix with a subset of the cols (perhaps in a different order).
            If the subsets happen to include all cols in the same order, the parent matrix is returned.
            This is a 'view' in the sense that changes to the values in either matrix will be reflected in both.
            </summary>
            <typeparam name="TRowKey">The type of the row key. Usually "String"</typeparam>
            <typeparam name="TColKey">The type of the col key. Usually "String"</typeparam>
            <typeparam name="TValue">The type of the value, for example, double, int, char, etc.</typeparam>
            <param name="parentMatrix">The matrix to wrap.</param>
            <param name="colIndexSequence">A sequence of col indexes that specifies the subset of cols to include and their desired order.</param>
            <returns>A matrix with the desired cols in their desired order.</returns>
        </member>
        <member name="M:Bio.Matrix.MatrixViewExtensions.SelectRowsView``3(Bio.Matrix.Matrix{``0,``1,``2},``0[])">
            <summary>
            Create a view of a parent matrix with a subset of the rows (perhaps in a different order).
            If the subset happens to include all rows in the same order, the parent matrix is returned.
            This is a 'view' in the sense that changes to the values in either matrix will be reflected in both.
            </summary>
            <typeparam name="TRowKey">The type of the row key. Usually "String"</typeparam>
            <typeparam name="TColKey">The type of the col key. Usually "String"</typeparam>
            <typeparam name="TValue">The type of the value, for example, double, int, char, etc.</typeparam>
            <param name="parentMatrix">The matrix to wrap.</param>
            <param name="rowKeyParams">a rowKey(s) that specifies the subset of row(s) to include (and their desired order).</param>
            <returns>A matrix with the desired row(s in their desired order).</returns>
        </member>
        <member name="M:Bio.Matrix.MatrixViewExtensions.SelectRowsView``3(Bio.Matrix.Matrix{``0,``1,``2},System.Int32[])">
            <summary>
            Create a view of a parent matrix with a subset of the rows (perhaps in a different order).
            If the subset happens to include all rows in the same order, the parent matrix is returned.
            This is a 'view' in the sense that changes to the values in either matrix will be reflected in both.
            </summary>
            <typeparam name="TRowKey">The type of the row key. Usually "String"</typeparam>
            <typeparam name="TColKey">The type of the col key. Usually "String"</typeparam>
            <typeparam name="TValue">The type of the value, for example, double, int, char, etc.</typeparam>
            <param name="parentMatrix">The matrix to wrap.</param>
            <param name="rowIndexParams">a row index(es) that specifies the subset of row(s) to include (and their desired order).</param>
            <returns>A matrix with the desired row(s in their desired order).</returns>
        </member>
        <member name="M:Bio.Matrix.MatrixViewExtensions.SelectColsView``3(Bio.Matrix.Matrix{``0,``1,``2},``1[])">
            <summary>
            Create a view of a parent matrix with a subset of the cols (perhaps in a different order).
            If the subset happens to include all cols in the same order, the parent matrix is returned.
            This is a 'view' in the sense that changes to the values in either matrix will be reflected in both.
            </summary>
            <typeparam name="TRowKey">The type of the row key. Usually "String"</typeparam>
            <typeparam name="TColKey">The type of the col key. Usually "String"</typeparam>
            <typeparam name="TValue">The type of the value, for example, double, int, char, etc.</typeparam>
            <param name="parentMatrix">The matrix to wrap.</param>
            <param name="colKeyParams">a colKey(s) that specifies the subset of col(s) to include (and their desired order).</param>
            <returns>A matrix with the desired col(s in their desired order).</returns>
        </member>
        <member name="M:Bio.Matrix.MatrixViewExtensions.SelectColsView``3(Bio.Matrix.Matrix{``0,``1,``2},System.Int32[])">
            <summary>
            Create a view of a parent matrix with a subset of the cols (perhaps in a different order).
            If the subset happens to include all cols in the same order, the parent matrix is returned.
            This is a 'view' in the sense that changes to the values in either matrix will be reflected in both.
            </summary>
            <typeparam name="TRowKey">The type of the row key. Usually "String"</typeparam>
            <typeparam name="TColKey">The type of the col key. Usually "String"</typeparam>
            <typeparam name="TValue">The type of the value, for example, double, int, char, etc.</typeparam>
            <param name="parentMatrix">The matrix to wrap.</param>
            <param name="colIndexParams">a col index(es) that specifies the subset of col(s) to include (and their desired order).</param>
            <returns>A matrix with the desired col(s in their desired order).</returns>
        </member>
        <member name="M:Bio.Matrix.MatrixViewExtensions.ConvertValueView``4(Bio.Matrix.Matrix{``0,``1,``2},Bio.Util.ValueConverter{``2,``3},``3)">
            <summary>
            Creates a view of a parent matrix that converts values. For example, if the parent has values '0' ... '9'
            of type character and doubles are needed, this view can convert the characters to double when reading.
            When double values are assigned, they would be converted to characters and stored in the parent matrix.
            If a conversion is impossible,an exception is raised.
            This is a 'view' in the sense that changes to the values in either matrix will be reflected in both.
            </summary>
            <remarks>If two layers of ConvertValueView are applied to a parent matrix, such that they cancel each other out,
            the parent matrix is returned.</remarks>
            <typeparam name="TRowKey">The type of the row key. Usually "String"</typeparam>
            <typeparam name="TColKey">The type of the col key. Usually "String"</typeparam>
            <typeparam name="TValueParent">The type of the parent's value, for example, char</typeparam>
            <typeparam name="TValueView">The type of the wrapper's value, for example, double</typeparam>
            <param name="parentMatrix">The matrix to wrap.</param>
            <param name="converter">A conversion instance, for example, ValueConvertion{char,int}.CharToInt</param>
            <param name="missingValue">The special Missing value for the wrapping matrix.</param>
            <returns>A matrix with values of the desired type</returns>
        </member>
        <member name="M:Bio.Matrix.MatrixViewExtensions.TransposeView``3(Bio.Matrix.Matrix{``0,``1,``2})">
            <summary>
            Create a view of the parent matrix in which rows become cols and cols become rows.
            This is a 'view' in the sense that changes to the values in either matrix will be reflected in both.
            </summary>
            <remarks>If two layers of TransposeView are applied to a parent matrix, the parent matrix is returned.</remarks>
            <typeparam name="TRowKey">The type of the row key. Usually "String"</typeparam>
            <typeparam name="TColKey">The type of the col key. Usually "String"</typeparam>
            <typeparam name="TValue">The type of the value, for example, double, int, char, etc.</typeparam>
            <param name="parentMatrix">The matrix to wrap.</param>
            <returns>A transposed matrix</returns>
        </member>
        <member name="M:Bio.Matrix.MatrixViewExtensions.RenameColsView``3(Bio.Matrix.Matrix{``0,``1,``2},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``1,``1}})">
            <summary>
            Create a new view of the parent matrix in which the columns are renamed
            This is a 'view' in the sense that changes to the values in either matrix will be reflected in both.
            </summary>
            <typeparam name="TRowKey">The type of the row key. Usually "String"</typeparam>
            <typeparam name="TColKey">The type of the col key. Usually "String"</typeparam>
            <typeparam name="TValue">The type of the value, for example, double, int, char, etc.</typeparam>
            <param name="parentMatrix">The matrix to wrap.</param>
            <param name="newKeyAndOldKeySequence">A sequence of pair mapping from new keys to the old keys, for example, a dictionary
            More than one new key can map to an old key.
            or a list of KeyValuePair's. Any parent column with a colKey that isn't mentioned will be inaccessable.
            The new cols will be in the order of given in the sequence.</param>
            <remarks>If newKeyAndOldKeySequence maps every key to itself, in the same order, the parent matrix will be returned.</remarks>
            <returns>A matrix with renamed columns.</returns>
        </member>
        <member name="M:Bio.Matrix.MatrixViewExtensions.RenameRowsView``3(Bio.Matrix.Matrix{``0,``1,``2},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``0}})">
            <summary>
            Create a new view of the parent matrix in which the rows are renamed.
            This is a 'view' in the sense that changes to the values in either matrix will be reflected in both.
            </summary>
            <typeparam name="TRowKey">The type of the row key. Usually "String"</typeparam>
            <typeparam name="TColKey">The type of the col key. Usually "String"</typeparam>
            <typeparam name="TValue">The type of the value, for example, double, int, char, etc.</typeparam>
            <param name="parentMatrix">The matrix to wrap.</param>
            <param name="newKeyAndOldKeySequence">A sequence of pair mapping from new keys to the old keys, for example, a dictionary
            More than one new key can map to an old key.
            or a list of KeyValuePair's. Any parent row with a rowKey that isn't mentioned will be inaccessable.
            The new rows will be in the order of given in the sequence.</param>
            <remarks>If newKeyAndOldKeySequence maps every key to itself, in the same order, the parent matrix will be returned.</remarks>
            <returns>A matrix with renamed rows.</returns>
        </member>
        <member name="M:Bio.Matrix.MatrixViewExtensions.MergeRowsView``3(Bio.Matrix.Matrix{``0,``1,``2},System.Boolean,Bio.Matrix.Matrix{``0,``1,``2}[])">
            <summary>
            Creates a new view in which the rows of the parent matrix is merged with the rows of the otherMatrices. The rows will be in the order
            of the input matrices. If two matrices contain a rows with the same rowKey, an exception is thrown. All matricies must have the same
            MissingValue.
            This is a 'view' in the sense that changes to the values in either matrix will be reflected in both.
            </summary>
            <typeparam name="TRowKey">The type of the row key. Usually "String"</typeparam>
            <typeparam name="TColKey">The type of the col key. Usually "String"</typeparam>
            <typeparam name="TValue">The type of the value, for example, double, int, char, etc.</typeparam>
            <param name="parentMatrix">The matrix to wrap.</param>
            <param name="colsMustMatch">true, to require all matrices to have the same colKeys in the same order; false, use an intersection of the
            colKeys in the order of parentMatrix.ColKeys.</param>
            <param name="otherMatrices">zero or more other matricies with which to concatinate rows.</param>
            <remarks>If no other matrices are given, returns the parent matrix.</remarks>
            <returns>A matrix containing the rows of parentMatrix and otherMatrices.</returns>
        </member>
        <member name="M:Bio.Matrix.MatrixViewExtensions.MergeColsView``3(Bio.Matrix.Matrix{``0,``1,``2},System.Boolean,Bio.Matrix.Matrix{``0,``1,``2}[])">
            <summary>
            Creates a new view in which the cols of the parent matrix is merged with the cols of the otherMatrices. The cols will be in the order
            of the input matrices. If two matrices contain a cols with the same colKey, an exception is thrown. All matricies must have the same
            MissingValue.
            This is a 'view' in the sense that changes to the values in either matrix will be reflected in both.
            </summary>
            <typeparam name="TRowKey">The type of the row key. Usually "String"</typeparam>
            <typeparam name="TColKey">The type of the col key. Usually "String"</typeparam>
            <typeparam name="TValue">The type of the value, for example, double, int, char, etc.</typeparam>
            <param name="parentMatrix">The matrix to wrap.</param>
            <param name="rowsMustMatch">true, to require all matrices to have the same rowKeys in the same order; false, use an intersection of the
            rowKeys in the order of parentMatrix.RowKeys.</param>
            <param name="otherMatrices">zero or more other matricies with which to concatinate cols.</param>
            <remarks>If no other matrices are given, returns the parent matrix.</remarks>
            <returns>A matrix containing the cols of parentMatrix and otherMatrices.</returns>
        </member>
        <member name="M:Bio.Matrix.MatrixViewExtensions.PermuteColValuesForEachRowView``3(Bio.Matrix.Matrix{``0,``1,``2},System.Collections.Generic.IEnumerable{``1})">
            <summary>
            Creates a new view in which the columns of the matrix (but not the column keys) are permuted.
            This is a 'view' in the sense that changes to the values in either matrix will be reflected in both.
            </summary>
            <typeparam name="TRowKey">The type of the row key. Usually "String"</typeparam>
            <typeparam name="TColKey">The type of the col key. Usually "String"</typeparam>
            <typeparam name="TValue">The type of the value, for example, double, int, char, etc.</typeparam>
            <param name="parentMatrix">The matrix to wrap.</param>
            <param name="colKeySequence">The colKeys of the columns in their new order. Every colKey must be mentioned exactly once.</param>
            <remarks>If the permutation puts every column back in the same place, the parent matrix is returned.</remarks>
            <returns>A new matrix with permuted columns.</returns>
        </member>
        <member name="M:Bio.Matrix.MatrixViewExtensions.PermuteColValuesForEachRowView``3(Bio.Matrix.Matrix{``0,``1,``2},System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Creates a new view in which the columns of the matrix (but not the column keys) are permuted.
            This is a 'view' in the sense that changes to the values in either matrix will be reflected in both.
            </summary>
            <typeparam name="TRowKey">The type of the row key. Usually "String"</typeparam>
            <typeparam name="TColKey">The type of the col key. Usually "String"</typeparam>
            <typeparam name="TValue">The type of the value, for example, double, int, char, etc.</typeparam>
            <param name="parentMatrix">The matrix to wrap.</param>
            <param name="colIndexSequence">The indexes of the columns in their new order. Every col index must be mentioned exactly once.</param>
            <remarks>If the permutation puts every column back in the same place, the parent matrix is returned.</remarks>
            <returns>A new matrix with permuted columns.</returns>
        </member>
        <member name="M:Bio.Matrix.MatrixViewExtensions.PermuteColValuesForEachRowView``3(Bio.Matrix.Matrix{``0,``1,``2},System.Random@)">
            <summary>
            Creates a new view in which the columns of the matrix (but not the column keys) are permuted.
            This is a 'view' in the sense that changes to the values in either matrix will be reflected in both.
            </summary>
            <typeparam name="TRowKey">The type of the row key. Usually "String"</typeparam>
            <typeparam name="TColKey">The type of the col key. Usually "String"</typeparam>
            <typeparam name="TValue">The type of the value, for example, double, int, char, etc.</typeparam>
            <param name="parentMatrix">The matrix to wrap.</param>
            <param name="random">a Random object from which a permutation is drawn</param>
            <remarks>If the permutation puts every column back in the same place, the parent matrix is returned.</remarks>
            <returns>A new matrix with permuted columns.</returns>
        </member>
        <member name="M:Bio.Matrix.MatrixViewExtensions.PermuteRowValuesForEachColView``3(Bio.Matrix.Matrix{``0,``1,``2},System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Creates a new view in which the rows of the matrix (but not the row keys) are permuted.
            This is a 'view' in the sense that changes to the values in either matrix will be reflected in both.
            </summary>
            <typeparam name="TRowKey">The type of the row key. Usually "String"</typeparam>
            <typeparam name="TColKey">The type of the col key. Usually "String"</typeparam>
            <typeparam name="TValue">The type of the value, for example, double, int, char, etc.</typeparam>
            <param name="parentMatrix">The matrix to wrap.</param>
            <param name="rowIndexSequence">The indexes of the rows in their new order. Every row index must be mentioned exactly once.</param>
            <remarks>If the permutation puts every row back in the same place, the parent matrix is returned.</remarks>
            <returns>A new matrix with permuted rows.</returns>
        </member>
        <member name="M:Bio.Matrix.MatrixViewExtensions.PermuteRowValuesForEachColView``3(Bio.Matrix.Matrix{``0,``1,``2},System.Random@)">
            <summary>
            Creates a new view in which the rows of the matrix (but not the row keys) are permuted.
            This is a 'view' in the sense that changes to the values in either matrix will be reflected in both.
            </summary>
            <typeparam name="TRowKey">The type of the row key. Usually "String"</typeparam>
            <typeparam name="TColKey">The type of the col key. Usually "String"</typeparam>
            <typeparam name="TValue">The type of the value, for example, double, int, char, etc.</typeparam>
            <param name="parentMatrix">The matrix to wrap.</param>
            <param name="random">a Random object from which a permutation is drawn</param>
            <remarks>If the permutation puts every row back in the same place, the parent matrix is returned.</remarks>
            <returns>A new matrix with permuted rows.</returns>
        </member>
        <member name="M:Bio.Matrix.MatrixViewExtensions.HashableView``3(Bio.Matrix.Matrix{``0,``1,``2})">
             <summary>
             Creates a view of the parent matrix which is hashable. For example, it can be used as the key of a dictionary.
             This is a 'view' in the sense that no copying an every little extra memory is used.
             
             Two HashableView matricies are equal if their RowKeys and ColKeys (in order), MissingValue, and values are equal.
             They will have the same hashcode if they are equal.
             
             The hashcode is computed only once when the the HashableView is contructed, so a HashableView does not allow
             its values to be changed. Also, changing values of the parent will give unexpected results.
             
             When used by Dictionary or HashSet, a full call of MatrixEquals (which looks at every value) is needed to confirm
             that two matrices with the same hashcode are really equal.
            </summary>
             <typeparam name="TRowKey">The type of the row key. Usually "String"</typeparam>
             <typeparam name="TColKey">The type of the col key. Usually "String"</typeparam>
             <typeparam name="TValue">The type of the value, for example, double, int, char, etc.</typeparam>
             <param name="parentMatrix">The matrix to wrap.</param>
             <returns>A hashable matrix</returns>
        </member>
        <member name="T:Bio.Matrix.MergeColsView`3">
            <summary>
            A wrapper around one or more parent matrices that created a merged view of their columns.
            Because it is a view, any changes made to the values of this matrix or the parents are reflected in all.
            </summary>
            <typeparam name="TRowKey">The type of the row key. Usually "String"</typeparam>
            <typeparam name="TColKey">The type of the col key. Usually "String"</typeparam>
            <typeparam name="TValue">The type of the value, for example, double, int, char, etc.</typeparam>
        </member>
        <member name="M:Bio.Matrix.MergeColsView`3.#ctor(System.Boolean,Bio.Matrix.Matrix{`0,`1,`2}[])">
            <summary>
            Creates a new view in which the cols of the matrices are merged. The cols will be in the order
            of the input matrices. If two matrices contain a rows with the same colKey, an exception is thrown. All matricies must have the same
            MissingValue.
            This is a 'view' in the sense that changes to the values in either matrix will be reflected in both.
            </summary>
            <param name="rowsMustMatch">true, to require all matrices to have the same rowKeys in the same order; false, use an intersection of the
            rowKeys in the order of RowKeys of the first matrix.</param>
            <param name="matrices">One or more matricies with which to concatinate cols.</param>
        </member>
        <member name="T:Bio.Matrix.MergeRowsView`3">
            <summary>
            A wrapper around one or more parent matrices that created a merged view of their rows.
            Because it is a view, any changes made to the values of this matrix or the parents are reflected in all.
            </summary>
            <typeparam name="TRowKey">The type of the row key. Usually "String"</typeparam>
            <typeparam name="TColKey">The type of the col key. Usually "String"</typeparam>
            <typeparam name="TValue">The type of the value, for example, double, int, char, etc.</typeparam>
        </member>
        <member name="M:Bio.Matrix.MergeRowsView`3.#ctor(System.Boolean,Bio.Matrix.Matrix{`0,`1,`2}[])">
            <summary>
            Creates a new view in which the rows of the matrices are merged. The rows will be in the order
            of the input matrices. If two matrices contain a rows with the same rowKey, an exception is thrown. All matricies must have the same
            MissingValue.
            This is a 'view' in the sense that changes to the values in either matrix will be reflected in both.
            </summary>
            <param name="colsMustMatch">true, to require all matrices to have the same colKeys in the same order; false, use an intersection of the
            colKeys in the order of ColKeys of the first matrix.</param>
            <param name="matrices">One or more matricies with which to concatinate rows.</param>
        </member>
        <member name="T:Bio.Matrix.PaddedDouble">
            <summary>
            A matrix object that reads double out of a file, as needed, rather than keeping them in memory.
            </summary>
        </member>
        <member name="F:Bio.Matrix.PaddedDouble.BytesPerValue">
            <summary>
            The number of ANSI characters in a file used to write out a double in text format.
            </summary>
        </member>
        <member name="F:Bio.Matrix.PaddedDouble.FormatString">
            <summary>
            The format string used to write doubles into ANSI text.
            </summary>
        </member>
        <member name="M:Bio.Matrix.PaddedDouble.StoreToSparseVal(System.Double)">
            <summary>
            A method that converts a double into a string suitable for writing to a file.
            </summary>
            <param name="store">The double</param>
            <returns>the string</returns>
        </member>
        <member name="F:Bio.Matrix.PaddedDouble.StaticMissingValue">
            <summary>
            The special value used to represent missing values. Always double.NaN.
            </summary>
        </member>
        <member name="F:Bio.Matrix.PaddedDouble.StaticStoreMissingValue">
            <summary>
            The special value used to represent missing values internally. Always double.NaN.
            </summary>
        </member>
        <member name="M:Bio.Matrix.PaddedDouble.CreateEmptyInstance(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Double)">
            <summary>
            Create an empty instance of a PaddedDouble file
            </summary>
            <param name="rowKeySequence">A sequence of row keys. The items will become the RowKeys of the Matrix.</param>
            <param name="colKeySequence">A sequence of colKeys. The items will come the ColKeys of the Matrix.</param>
            <param name="missingValue">The special value that represents missing</param>
            <returns>An empty PaddedDouble instance</returns>
        </member>
        <member name="M:Bio.Matrix.PaddedDouble.TryGetInstanceFromSparse(System.String,Bio.Matrix.Matrix{System.String,System.String,System.Double}@)">
            <summary>
            Create an instance of PaddedDouble from a sparse input file
            </summary>
            <param name="inputSparsePattern">The sparse input file</param>
            <param name="matrix">The PaddedDouble matrix created</param>
            <returns>true if the file parses as PaddedDouble; otherwise, false</returns>
        </member>
        <member name="M:Bio.Matrix.PaddedDouble.TryGetInstanceFromSparse(System.String,Bio.Matrix.PaddedDouble@)">
            <summary>
            Create an instance of PaddedDouble from a sparse input file
            </summary>
            <param name="inputSparsePattern">The sparse input file</param>
            <param name="paddedDouble">The PaddedDouble matrix created</param>
            <returns>true if the file parses as PaddedDouble; otherwise, false</returns>
        </member>
        <member name="M:Bio.Matrix.PaddedDouble.GetInstanceFromSparse(System.String)">
            <summary>
            Create an instance of PaddedDouble from a sparse input file
            </summary>
            <param name="inputSparsePattern">The sparse input file</param>
            <returns>A PaddedDouble</returns>
        </member>
        <member name="M:Bio.Matrix.PaddedDouble.GetInstanceFromSparse(System.Collections.Generic.IEnumerable{Bio.Matrix.RowKeyColKeyValue{System.String,System.String,System.Double}})">
            <summary>
            Create a PaddedDouble object from a sequence of RowKeyColKeyValue triples.
            </summary>
            <param name="tripleEnumerable">a sequence of RowKeyColKeyValue</param>
            <returns>A PaddedDouble object</returns>
        </member>
        <member name="M:Bio.Matrix.PaddedDouble.TryGetInstance(System.String,System.Double,System.Threading.Tasks.ParallelOptions,Bio.Matrix.Matrix{System.String,System.String,System.Double}@)">
            <summary>
            This awkward method is provided for the sake of MatrixFactory. Right now it simply catches exceptions. Should switch and make it fail silently when doesn't work.
            </summary>
        </member>
        <member name="M:Bio.Matrix.PaddedDouble.GetInstance(System.String,System.Threading.Tasks.ParallelOptions)">
            <summary>
            Creates an instance of PaddedDouble from a file in PaddedDouble format.
            </summary>
            <param name="paddedDoubleFileName">a file in PaddedDouble format</param>
            <param name="parallelOptions">A ParallelOptions instance that configures the multithreaded behavior of this operation.</param>
            <returns>The created PaddedDouble</returns>
        </member>
        <member name="M:Bio.Matrix.PaddedDouble.EachSparseLine(System.String,System.Boolean,System.String,Bio.Util.CounterWithMessages)">
            <summary>
            Returns the contents of a files in PaddedDouble format as a sequence of string arrays in sparse file format.
            Saves memory by never creating a PaddedDouble instance.
            </summary>
            <param name="filePattern">Files in PaddedDouble format</param>
            <param name="zeroIsOK">tells if it's OK if not files match parts of the file pattern.</param>
            <param name="fileMessageOrNull">A string containing '{0}' to write as each file is opened.</param>
            <param name="counterWithMessages">Send status messages to standard output</param>
            <returns>A sequence of string arrays. Each string array has three values: the var, the cid, and the val.</returns>
        </member>
        <member name="T:Bio.Matrix.PaddedDoubleExtensions">
            <summary>
            Extension methods on Matrix related to PaddedDouble.
            </summary>
        </member>
        <member name="M:Bio.Matrix.PaddedDoubleExtensions.AsPaddedDouble(Bio.Matrix.Matrix{System.String,System.String,System.Double},System.Threading.Tasks.ParallelOptions)">
            <summary>
            Converts matrix to a PaddedDouble. If matrix is already a dense collection, then returns the given matrix without copying. 
            </summary>
            <param name="inputMatrix">The matrix to convert from</param>
            <param name="parallelOptions">A ParallelOptions instance that configures the multithreaded behavior of this operation.</param>
            <returns>A paddedDouble version of the matrix</returns>
        </member>
        <member name="M:Bio.Matrix.PaddedDoubleExtensions.ToPaddedDouble(Bio.Matrix.Matrix{System.String,System.String,System.Double},System.Threading.Tasks.ParallelOptions)">
            <summary>
            Converts matrix to a PaddedDouble. Even if the matrix is already an paddedDouble, a new one is created.. 
            </summary>
            <param name="matrix">The matrix to convert from</param>
            <param name="parallelOptions">A ParallelOptions instance that configures the multithreaded behavior of this operation.</param>
            <returns>A paddedDouble version of the matrix</returns>
        </member>
        <member name="M:Bio.Matrix.PaddedDoubleExtensions.WritePaddedDouble(Bio.Matrix.Matrix{System.String,System.String,System.Double},System.String,System.Threading.Tasks.ParallelOptions)">
            <summary>
            Write a matrix in PaddedDouble file format
            </summary>
            <param name="matrix">The matrix to write</param>
            <param name="filename">The file to write to</param>
            <param name="parallelOptions">A ParallelOptions instance that configures the multithreaded behavior of this operation.</param>
        </member>
        <member name="M:Bio.Matrix.PaddedDoubleExtensions.WritePaddedDouble(Bio.Matrix.Matrix{System.String,System.String,System.Double},System.IO.TextWriter,System.Threading.Tasks.ParallelOptions)">
            <summary>
            Write in PaddedDouble file format to a TextWriter
            </summary>
            <param name="matrix">The matrix to write</param>
            <param name="textWriter">The TextWriter to write to</param>
            <param name="parallelOptions">A ParallelOptions instance that configures the multithreaded behavior of this operation.</param>
        </member>
        <member name="T:Bio.Matrix.PermuteValuesView`3">
            <summary>
            A wrapper around a parent matrix that permutes the values by column.
            e.g. Before m1=
                     cid0 cid1 cid2
                v0    a     b   c
                v1    d    null f
                v2    null null i
                
                m1.PermuteValuesView(1, 2, 0) =
                     cid0 cid1 cid2
                v0    b    c    a
                v1    null f   d
                v2    null i   null
            
            
            Because it is a view, any changes made to the values of this matrix or the parent matrix are reflected in both.
            </summary>
            <typeparam name="TRowKey">The type of the row key. Usually "String"</typeparam>
            <typeparam name="TColKey">The type of the col key. Usually "String"</typeparam>
            <typeparam name="TValue">The type of the value, for example, double, int, char, etc.</typeparam>
        </member>
        <member name="P:Bio.Matrix.PermuteValuesView`3.ParentMatrix">
            <summary>
            The matrix that this view wraps.
            </summary>
        </member>
        <member name="P:Bio.Matrix.PermuteValuesView`3.IndexOfParentCol">
            <summary>
            Given a colIndex value tells the cooresponding colIndex in the parent matrix.
            </summary>
        </member>
        <member name="T:Bio.Matrix.RenameColsView`3">
            <summary>
            A wrapper around a parent matrix that allows col keys to be renamed and/or expanded. If expanded, then multiple keys will
            point to the same underlying row, meaning change to a value in one row will be reflected in another row.
            Also, because it is a view, any changes made to the values of this matrix or the parent matrix are reflected in both.
            </summary>
            <typeparam name="TRowKey">The type of the row key. Usually "String"</typeparam>
            <typeparam name="TColKey">The type of the col key. Usually "String"</typeparam>
            <typeparam name="TValue">The type of the value, for example, double, int, char, etc.</typeparam>
        </member>
        <member name="P:Bio.Matrix.RenameColsView`3.ParentMatrix">
            <summary>
            The matrix that this view wraps.
            </summary>
        </member>
        <member name="P:Bio.Matrix.RenameColsView`3.NewKeyToOldKey">
            <summary>
            A read-only dictionary giving the mapping from the col keys of this matrix to the col keys of its parent matrix.
            </summary>
        </member>
        <member name="P:Bio.Matrix.RenameColsView`3.NewIndexToOldIndex">
            <summary>
            A read-only dictionary giving the mapping from the col index of this matrix to the col index of it's parent matrix
            </summary>
        </member>
        <member name="T:Bio.Matrix.RowKeysAnsi">
            <summary>
            Be sure to use this is a "Using" to that it gets disposed correctly.
            </summary>
        </member>
        <member name="T:Bio.Matrix.RowKeysStructMatrix`1">
            <summary>
            An abstract Matrix class for accessing values off disk instead of keeping them memory. For example, RowKeysAnsi
            is a subclass that access values from DenseAnsi format. The on-disk file format must be a subtype of DenseStructMatrix, 
            for example, DenseAnsi or PaddedDouble. The method is IDisposable and should be used with a 'Using' statement or should be closed.
            </summary>
            <typeparam name="TValue">The type of the value</typeparam>
        </member>
        <member name="M:Bio.Matrix.RowKeysStructMatrix`1.ByteArrayToValueOrMissing(System.Byte[])">
            <summary>
            A method that converts bytes (read from the on-disk file) into a value.
            </summary>
            <param name="byteArray">bytes from the on-disk file</param>
            <returns>a value</returns>
        </member>
        <member name="M:Bio.Matrix.RowKeysStructMatrix`1.ValueOrMissingToByteArray(`0)">
            <summary>
            A method that converts a value (including the special missing value) to an array of bytes.
            </summary>
            <param name="value">The value to convert</param>
            <returns>The byte array</returns>
        </member>
        <member name="F:Bio.Matrix.RowKeysStructMatrix`1.ColSerialNumbers">
            <summary>
            The mapping from column keys to column indexes.
            </summary>
        </member>
        <member name="M:Bio.Matrix.RowKeysStructMatrix`1.WriteRowKeys(System.String)">
            <summary>
            Write out the RowKeys file for a matrix. This file is an index to the rows of another file.
            </summary>
            <param name="simpleFileName">The rowKeys file to write to. It must not include any path information. It will be created in the other file's directory.</param>
        </member>
        <member name="M:Bio.Matrix.RowKeysStructMatrix`1.GetInstanceFromRowKeysStructFileNameInternal(System.String,System.Threading.Tasks.ParallelOptions,System.IO.FileAccess,System.IO.FileShare,System.Boolean)">
            <summary>
            Get a instance from a file in a RowKeys format
            </summary>
            <param name="rowKeysStructFileName">The rowKeys file</param>
            <param name="parallelOptions">A ParallelOptions instance that configures the multithreaded behavior of this operation.</param>
            <param name="fileAccess">A FileAccess value that specifies the operations that can be performed on the file. Defaults to 'Read'</param>
            <param name="fileShare">A FileShare value specifying the type of access other threads have to the file. Defaults to 'Read'</param>
            <param name="verbose"></param>
        </member>
        <member name="M:Bio.Matrix.RowKeysStructMatrix`1.GetInstanceFromDenseStructFileNameInternal(System.String,System.Threading.Tasks.ParallelOptions,System.IO.FileAccess,System.IO.FileShare)">
            <summary>
            Used by subclasses, such as RowKeyAnsi, to open a file on disk.
            The enseStructFileNam is IDisposable and so should be disposed of, for example, with the 'using  statement'.
            </summary>
            <param name="denseStructFileName">The file on disk to open</param>
            <param name="parallelOptions">A ParallelOptions instance that configures the multithreaded behavior of this operation.</param>
            <param name="fileAccess">A FileAccess value that specifies the operations that can be performed on the file. Defaults to 'Read'</param>
            <param name="fileShare">A FileShare value specifying the type of access other threads have to the file. Defaults to 'Read'</param>
        </member>
        <member name="P:Bio.Matrix.RowKeysStructMatrix`1.BytesPerValue">
            <summary>
            The number of bytes per value in the on-disk file format.
            </summary>
        </member>
        <member name="M:Bio.Matrix.RowKeysAnsi.GetInstanceFromDenseAnsi(System.String,System.Threading.Tasks.ParallelOptions,System.IO.FileAccess,System.IO.FileShare)">
            <summary>
            Create an instance of RowKeysAnsi from a file in DenseAnsi format.
            The RowKeysAnsi is IDisposable and so should be disposed of, for example, with the 'using  statement'.
            </summary>
            <param name="denseAnsiFileName">The DenseAnsi file</param>
            <param name="parallelOptions">A ParallelOptions instance that configures the multithreaded behavior of this operation.</param>
            <param name="fileAccess">A FileAccess value that specifies the operations that can be performed on the file. Defaults to 'Read'</param>
            <param name="fileShare">A FileShare value specifying the type of access other threads have to the file. Defaults to 'Read'</param>
            <returns>A RowKeysAnsi object</returns>
        </member>
        <member name="M:Bio.Matrix.RowKeysAnsi.GetInstanceFromRowKeysAnsi(System.String,System.Threading.Tasks.ParallelOptions,System.IO.FileAccess,System.IO.FileShare,System.Boolean)">
            <summary>
            Create an instance of RowKeysAnsi from a file in RowKeysAnsi format.
            The RowKeysAnsi is IDisposable and so should be disposed of, for example, with the 'using  statement'.
            </summary>
            <param name="rowKeysAnsiFileName">The rowKeys ansi file</param>
            <param name="parallelOptions">A ParallelOptions instance that configures the multithreaded behavior of this operation.</param>
            <param name="fileAccess">A FileAccess value that specifies the operations that can be performed on the file. Defaults to 'Read'</param>
            <param name="fileShare">A FileShare value specifying the type of access other threads have to the file. Defaults to 'Read'</param>
            <param name="verbose"></param>
            <returns>a RowKeysAnsi instance</returns>
        </member>
        <member name="T:Bio.Matrix.RowKeysPaddedDouble">
            <summary>
            Be sure to use this is a "Using" to that it gets disposed correctly.
            </summary>
        </member>
        <member name="M:Bio.Matrix.RowKeysPaddedDouble.GetInstanceFromPaddedDouble(System.String,System.Threading.Tasks.ParallelOptions,System.IO.FileAccess,System.IO.FileShare)">
            <summary>
            Create an instance of RowKeysPaddedDouble from a file in PaddedDouble format.
            The RowKeysPaddedDouble is IDisposable and so should be disposed of, for example, with the 'using  statement'.
            </summary>
            <param name="paddedDoubleFileName">The PaddedDouble file</param>
            <param name="parallelOptions">A ParallelOptions instance that configures the multithreaded behavior of this operation.</param>
            <param name="fileAccess">A FileAccess value that specifies the operations that can be performed on the file. Defaults to 'Read'</param>
            <param name="fileShare">A FileShare value specifying the type of access other threads have to the file. Defaults to 'Read'</param>
            <returns>A RowKeysPaddedDouble object</returns>
        </member>
        <member name="M:Bio.Matrix.RowKeysPaddedDouble.GetInstanceFromRowKeys(System.String,System.Threading.Tasks.ParallelOptions,System.IO.FileAccess,System.IO.FileShare)">
            <summary>
            Create an instance of RowKeysPaddedDouble from a file in RowKeysPaddedDouble format.
            The RowKeysPaddedDouble is IDisposable and so should be disposed of, for example, with the 'using  statement'.
            </summary>
            <param name="rowKeysFileName">The RowKeysPaddedDouble file</param>
            <param name="parallelOptions">A ParallelOptions instance that configures the multithreaded behavior of this operation.</param>
            <param name="fileAccess">A FileAccess value that specifies the operations that can be performed on the file. Defaults to 'Read'</param>
            <param name="fileShare">A FileShare value specifying the type of access other threads have to the file. Defaults to 'Read'</param>
            <returns>A RowKeysPaddedDouble object</returns>
        </member>
        <member name="T:Bio.Matrix.RowKeysPairAnsi">
            <summary>
            Be sure to use this is a "Using" to that it gets disposed correctly.
            </summary>
        </member>
        <member name="M:Bio.Matrix.RowKeysPairAnsi.GetInstanceFromPairAnsi(System.String,System.Threading.Tasks.ParallelOptions,System.IO.FileAccess,System.IO.FileShare)">
            <summary>
            Create an instance of RowKeysPairAnsi from a file in DensePairAnsi format.
            The RowKeysPairAnsi is IDisposable and so should be disposed of, for example, with the 'using  statement'.
            </summary>
            <param name="pairAnsiFileName">The pairAnsi file</param>
            <param name="parallelOptions">A ParallelOptions instance that configures the multithreaded behavior of this operation.</param>
            <param name="fileAccess">A FileAccess value that specifies the operations that can be performed on the file. Defaults to 'Read'</param>
            <param name="fileShare">A FileShare value specifying the type of access other threads have to the file. Defaults to 'Read'</param>
            <returns>A RowKeysPairAnsi object </returns>
        </member>
        <member name="M:Bio.Matrix.RowKeysPairAnsi.GetInstanceFromRowKeysAnsi(System.String,System.Threading.Tasks.ParallelOptions,System.IO.FileAccess,System.IO.FileShare)">
            <summary>
            Create an instance of RowKeysPairAnsi from a file in RowKeysPairAnsi format.
            The RowKeysPairAnsi is IDisposable and so should be disposed of, for example, with the 'using  statement'.
            </summary>
            <param name="rowKeysAnsiFileName">The RowKeysPairAnsi file</param>
            <param name="parallelOptions">A ParallelOptions instance that configures the multithreaded behavior of this operation.</param>
            <param name="fileAccess">A FileAccess value that specifies the operations that can be performed on the file. Defaults to 'Read'</param>
            <param name="fileShare">A FileShare value specifying the type of access other threads have to the file. Defaults to 'Read'</param>
            <returns>A RowKeysPairAnsi object</returns>
        </member>
        <member name="T:Bio.Matrix.SelectRowsAndColsView`3">
            <summary>
            A wrapper around a parent matrix that can select a subset of rows and cols. It can also change the order
            of the row keys and col keys.
            Because it is a view, any changes made to the values of this matrix or the parent matrix are reflected in both.
            </summary>
            <typeparam name="TRowKey">The type of the row key. Usually "String"</typeparam>
            <typeparam name="TColKey">The type of the col key. Usually "String"</typeparam>
            <typeparam name="TValue">The type of the value, for example, double, int, char, etc.</typeparam>
        </member>
        <member name="F:Bio.Matrix.SelectRowsAndColsView`3.IndexOfParentRowKey">
            <summary>
            A read-only list that maps a row index for this matrix into a row index of the parent matrix
            </summary>
        </member>
        <member name="F:Bio.Matrix.SelectRowsAndColsView`3.IndexOfParentColKey">
            <summary>
            A read-only list that maps a col index for this matrix into a col index of the parent matrix
            </summary>
        </member>
        <member name="P:Bio.Matrix.SelectRowsAndColsView`3.ParentMatrix">
            <summary>
            The matrix that this view wraps.
            </summary>
        </member>
        <member name="T:Bio.Matrix.SequenceToMatrixConversion">
            <summary>
            Static class converting sequence to Matrix. 
            </summary>
        </member>
        <member name="M:Bio.Matrix.SequenceToMatrixConversion.TryGetMatrixFromSequenceFileAndPossiblyConvertDna2AaKeepOneValueVariables``3(System.String,``2,System.Threading.Tasks.ParallelOptions,Bio.Matrix.Matrix{``0,``1,``2}@)">
            <summary>
            Constructs Protein matrix from DNA sequence by keeping one value variables in matrix. 
            </summary>
            <typeparam name="TRow">Row type of matrix.</typeparam>
            <typeparam name="TCol">Column type of matrix</typeparam>
            <typeparam name="TVal">Value of matrix.</typeparam>
            <param name="filename">Sequence file path.</param>
            <param name="missing">The special value that represents missing.</param>
            <param name="parallelOptions">A ParallelOptions instance that configures the multithreaded behavior of this operation.</param>
            <param name="matrix">The matrix created</param>
            <returns>True if the function was able to create a matrix from the information in the file; otherwise, false</returns>
        </member>
        <member name="M:Bio.Matrix.SequenceToMatrixConversion.TryGetMatrixFromSequenceFileKeepOneValueVariables``3(System.String,``2,System.Threading.Tasks.ParallelOptions,Bio.Matrix.Matrix{``0,``1,``2}@)">
            <summary>
            Constructs DNA matrix from DNA sequence by keeping one value variables in matrix. 
            </summary>
            <typeparam name="TRow">Row type of matrix.</typeparam>
            <typeparam name="TCol">Column type of matrix</typeparam>
            <typeparam name="TVal">Value of matrix.</typeparam>
            <param name="filename">Sequence file path.</param>
            <param name="missing">The special value that represents missing.</param>
            <param name="parallelOptions">A ParallelOptions instance that configures the multithreaded behavior of this operation.</param>
            <param name="matrix">The matrix created</param>
            <returns>True if the function was able to create a matrix from the information in the file; otherwise, false</returns>
        </member>
        <member name="M:Bio.Matrix.SequenceToMatrixConversion.TryGetMatrixFromSequenceFileAndPossiblyConvertDna2AaIgnoreOneValueVariables``3(System.String,``2,System.Threading.Tasks.ParallelOptions,Bio.Matrix.Matrix{``0,``1,``2}@)">
            <summary>
            Constructs Protein matrix from DNA sequence by not keeping one value variables in matrix. 
            </summary>
            <typeparam name="TRow">Row type of matrix.</typeparam>
            <typeparam name="TCol">Column type of matrix</typeparam>
            <typeparam name="TVal">Value of matrix.</typeparam>
            <param name="filename">Sequence file path.</param>
            <param name="missing">The special value that represents missing.</param>
            <param name="parallelOptions">A ParallelOptions instance that configures the multithreaded behavior of this operation.</param>
            <param name="matrix">The matrix created</param>
            <returns>True if the function was able to create a matrix from the information in the file; otherwise, false</returns>
        </member>
        <member name="M:Bio.Matrix.SequenceToMatrixConversion.TryGetMatrixFromSequenceFileIgnoreOneValueVariables``3(System.String,``2,System.Threading.Tasks.ParallelOptions,Bio.Matrix.Matrix{``0,``1,``2}@)">
            <summary>
            Constructs DNA matrix from DNA sequence by ignoring one value variables in matrix. 
            </summary>
            <typeparam name="TRow">Row type of matrix.</typeparam>
            <typeparam name="TCol">Column type of matrix</typeparam>
            <typeparam name="TVal">Value of matrix.</typeparam>
            <param name="filename">Sequence file path.</param>
            <param name="missing">The special value that represents missing.</param>
            <param name="parallelOptions">A ParallelOptions instance that configures the multithreaded behavior of this operation.</param>
            <param name="matrix">The matrix created</param>
            <returns>True if the function was able to create a matrix from the information in the file; otherwise, false</returns>
        </member>
        <member name="M:Bio.Matrix.SequenceToMatrixConversion.TryGetMatrixFromSequenceFileForDNASequence``3(System.String,System.Boolean,Bio.Matrix.Matrix{``0,``1,``2}@)">
            <summary>
            Constructs DNA matrix from DNA sequence.
            </summary>
            <typeparam name="TRow">Row type of matrix.</typeparam>
            <typeparam name="TCol">Column type of matrix</typeparam>
            <typeparam name="TVal">Value of matrix.</typeparam>
            <param name="filename">Sequence file path.</param>
            <param name="keepOneValueVariables">Keeps variables with single value only.</param>
            <param name="matrix">The matrix created</param>
            <returns>True if the function was able to create a matrix from the information in the file; otherwise, false</returns>
        </member>
        <member name="M:Bio.Matrix.SequenceToMatrixConversion.TryGetMatrixFromSequenceFileAndPossiblyConvertDNAToRNA``3(System.String,System.Boolean,Bio.Matrix.Matrix{``0,``1,``2}@)">
            <summary>
            Constructs RNA matrix from DNA sequence. 
            </summary>
            <typeparam name="TRow">Row type of matrix.</typeparam>
            <typeparam name="TCol">Column type of matrix</typeparam>
            <typeparam name="TVal">Value of matrix.</typeparam>
            <param name="filename">Sequence file path.</param>
            <param name="keepOneValueVariables">Keeps variables with single value only.</param>
            <param name="matrix">The matrix created</param>
            <returns>True if the function was able to create a matrix from the information in the file; otherwise, false</returns>
        </member>
        <member name="M:Bio.Matrix.SequenceToMatrixConversion.TryGetMatrixFromSequenceFileAndPossiblyConvertDNAToProtein``3(System.String,System.Boolean,Bio.Matrix.Matrix{``0,``1,``2}@,System.Int32,System.Boolean)">
            <summary>
            Constructs Protein matrix from DNA sequence.
            </summary>
            <typeparam name="TRow">Row type of matrix.</typeparam>
            <typeparam name="TCol">Column type of matrix</typeparam>
            <typeparam name="TVal">Value of matrix.</typeparam>
            <param name="filename">Sequence file path.</param>
            <param name="keepOneValueVariables">Keeps variables with single value only.</param>
            <param name="matrix">The matrix created</param>
            <param name="readingFrame">Reading frame used for translation.</param>
            <param name="isMissing">Treat gap as missing values.</param>
            <returns>True if the function was able to create a matrix from the information in the file; otherwise, false</returns>
        </member>
        <member name="M:Bio.Matrix.SequenceToMatrixConversion.TryGetMatrixFromSequenceFileForRNASequence``3(System.String,System.Boolean,Bio.Matrix.Matrix{``0,``1,``2}@)">
            <summary>
            Constructs RNA matrix from RNA sequence.
            </summary>
            <typeparam name="TRow">Row type of matrix.</typeparam>
            <typeparam name="TCol">Column type of matrix</typeparam>
            <typeparam name="TVal">Value of matrix.</typeparam>
            <param name="filename">Sequence file path.</param>
            <param name="keepOneValueVariables">Keeps variables with single value only.</param>
            <param name="matrix">The matrix created</param>
            <returns>True if the function was able to create a matrix from the information in the file; otherwise, false</returns>
        </member>
        <member name="M:Bio.Matrix.SequenceToMatrixConversion.TryGetMatrixFromSequenceFileAndPossiblyConvertRNAToProtein``3(System.String,System.Boolean,Bio.Matrix.Matrix{``0,``1,``2}@,System.Int32,System.Boolean)">
            <summary>
            Constructs Protein matrix from RNA sequence.
            </summary>
            <typeparam name="TRow">Row type of matrix.</typeparam>
            <typeparam name="TCol">Column type of matrix</typeparam>
            <typeparam name="TVal">Value of matrix.</typeparam>
            <param name="filename">Sequence file path.</param>
            <param name="keepOneValueVariables">Keeps variables with single value only.</param>
            <param name="matrix">The matrix created</param>
            <param name="readingFrame">Reading frame used for translation.</param>
            <param name="isMissing">Treat gap as missing values.</param>
            <returns>True if the function was able to create a matrix from the information in the file; otherwise, false</returns>
        </member>
        <member name="M:Bio.Matrix.SequenceToMatrixConversion.TryGetMatrixFromSequenceFileForProteinSequence``3(System.String,System.Boolean,Bio.Matrix.Matrix{``0,``1,``2}@)">
            <summary>
            Constructs Protein matrix from Protein sequence.
            </summary>
            <typeparam name="TRow">Row type of matrix.</typeparam>
            <typeparam name="TCol">Column type of matrix</typeparam>
            <typeparam name="TVal">Value of matrix.</typeparam>
            <param name="filename">Sequence file path.</param>
            <param name="keepOneValueVariables">Keeps variables with single value only.</param>
            <param name="matrix">The matrix created</param>
            <returns>True if the function was able to create a matrix from the information in the file; otherwise, false</returns>
        </member>
        <member name="M:Bio.Matrix.SequenceToMatrixConversion.ValidateSequences(System.Collections.Generic.IList{Bio.ISequence})">
            <summary>
            Validate sequence length are equal or not.
            In Multiple Sequence Alignment, all sequences have equal lengths. 
            </summary>
            <param name="sequences">Input sequences.</param>
        </member>
        <member name="M:Bio.Matrix.SequenceToMatrixConversion.RemoveAmbigiousProteinCharacters(Bio.ISequence)">
            <summary>
            Remove ambiguous protein characters by converting them into unambiguous characters.
            </summary>
            <param name="seq">Protein sequence.</param>
            <returns>List of List of protein alphabets. </returns>
        </member>
        <member name="M:Bio.Matrix.SequenceToMatrixConversion.RemoveAmbigiousRNACharacters(Bio.ISequence)">
            <summary>
            Remove ambiguous RNA characters by converting them into unambiguous characters.
            </summary>
            <param name="seq">RNA sequence.</param>
            <returns>List of List of RNA alphabets. </returns>
        </member>
        <member name="M:Bio.Matrix.SequenceToMatrixConversion.RemoveAmbigiousDNACharacters(Bio.ISequence)">
            <summary>
            Remove ambiguous DNA characters by converting them into unambiguous characters.
            </summary>
            <param name="seqs">DNA sequence.</param>
            <returns>List of List of DNA alphabets. </returns>
        </member>
        <member name="M:Bio.Matrix.SequenceToMatrixConversion.ConvertDNAToRNA(Bio.ISequence)">
            <summary>
            Transcription (Converts DNA to RNA alphabets.)
            </summary>
            <param name="seq">DNA sequence.</param>
            <returns>List of List unambiguous RNA characters.</returns>
        </member>
        <member name="M:Bio.Matrix.SequenceToMatrixConversion.TryCreateMatrix``3(System.Collections.Generic.IList{System.Collections.Generic.IList{System.Collections.Generic.IList{System.Byte}}},System.Collections.Generic.IEnumerable{System.String},System.Boolean,Bio.Matrix.Matrix{``0,``1,``2}@)">
            <summary>
            Create Matrix from positional sequence variation. 
            </summary>
            <typeparam name="TRow">Row type of matrix.</typeparam>
            <typeparam name="TCol">Column type of matrix</typeparam>
            <typeparam name="TVal">Value of matrix.</typeparam>
            <param name="sequences">List of List of positional sequence variation.</param>
            <param name="headerValues">Values of column headers of matrix</param>
            <param name="keepOneValueVariables">Keeps variables with single value only.</param>
            <param name="matrix">The matrix created</param>
            <returns>True if the function was able to create a matrix from the information in the file; otherwise, false</returns>
        </member>
        <member name="M:Bio.Matrix.SequenceToMatrixConversion.CreateSequenceStatistics(System.Collections.Generic.HashSet{System.Byte}[],System.Collections.Generic.IList{System.Collections.Generic.IList{System.Collections.Generic.IList{System.Byte}}},System.Boolean,System.Collections.Generic.IList{System.String}@)">
            <summary>
            Converts positional variations in sequences to statistics
            </summary>
            <param name="positionalAminoAcidDistribution">Positional distribution of alphabets.</param>
            <param name="sequences">List of List of positional sequence variation.</param>
            <param name="keepOneValueVariables">Keeps variables with single value only.</param>
            <param name="rowValues">Values in rows</param>
            <returns>Positional sequence statistics</returns>
        </member>
        <member name="M:Bio.Matrix.SequenceToMatrixConversion.ConvertBinaryToMultistate(System.Collections.Generic.IList{System.Collections.Generic.List{Bio.Distributions.SufficientStatistics}},System.Collections.Generic.IList{System.String})">
            <summary>
            Convert Binary To Multistate.
            </summary>
            <param name="statistics">statistics.</param>
            <param name="columnValues">column Values.</param>
        </member>
        <member name="M:Bio.Matrix.SequenceToMatrixConversion.GetMerAndPos(System.String)">
            <summary>
            Get Mer And Pos.
            </summary>
            <param name="variableName">Variable name.</param>
            <returns>Returns KeyValuePair of string and double.</returns>
        </member>
        <member name="M:Bio.Matrix.SequenceToMatrixConversion.TryGetMerAndPos(System.String,System.Collections.Generic.KeyValuePair{System.String,System.Double}@)">
            <summary>
            Try Get Mer And Pos.
            </summary>
            <param name="variableName">Variable name.</param>
            <param name="merAndPos">KeyValuePair of string and double. </param>
            <returns></returns>
        </member>
        <member name="M:Bio.Matrix.SequenceToMatrixConversion.Translation(Bio.ISequence,System.Int32,System.Boolean,Bio.IAlphabet)">
            <summary>
            Translation.
            </summary>
            <param name="sequence">The sequence.</param>
            <param name="readingFrame">The readingFrame.</param>
            <param name="isMissing">IsMissing flag.</param>
            <param name="alphabet">The Alphabet.</param>
            <returns>Returns list of list of bytes.</returns>
        </member>
        <member name="M:Bio.Matrix.SequenceToMatrixConversion.GetAminoAcidsUsingAmbigiousRNACodons(System.Byte,System.Byte,System.Byte)">
            <summary>
            Get Amino Acids Using Ambiguous RNA Codons.
            </summary>
            <param name="firstPos">First position.</param>
            <param name="secondPos">Second position.</param>
            <param name="thirdPos">Third position.</param>
            <returns>Returns list of bytes.</returns>
        </member>
        <member name="M:Bio.Matrix.SequenceToMatrixConversion.GetAminoAcidsUsingAmbigiousDNACodons(System.Byte,System.Byte,System.Byte)">
            <summary>
            Get Amino Acids Using Ambiguous DNA Codons.
            </summary>
            <param name="firstPos">First position.</param>
            <param name="secondPos">Second position.</param>
            <param name="thirdPos">Third position.</param>
            <returns>Returns list of bytes.</returns>
        </member>
        <member name="M:Bio.Matrix.SequenceToMatrixConversion.TryParseSequenceFile(System.String,Bio.IAlphabet,System.Collections.Generic.IList{Bio.ISequence}@)">
            <summary>
            Try Parse Sequence File.
            </summary>
            <param name="fileName">The fileName.</param>
            <param name="alphabet">The Alphabet.</param>
            <param name="sequences">List of sequences.</param>
            <returns>True if Parsed sequence properly.</returns>
        </member>
        <member name="M:Bio.Matrix.SequenceToMatrixConversion.ValidatePhylipFormat(System.String)">
            <summary>
            Conforms the file format using information in first line of file.
            </summary>
            <param name="firstLine">First line of file.</param>
            <returns>Whether file is in phylip format or not.</returns>
        </member>
        <member name="M:Bio.Matrix.SequenceToMatrixConversion.ValidateTabFormat(System.String)">
            <summary>
            Conforms the file format using information in first line of file.
            </summary>
            <param name="firstLine">First line of file.</param>
            <returns>Whether file is in tab format or not.</returns>
        </member>
        <member name="M:Bio.Matrix.SequenceToMatrixConversion.ValidateFastaFormat(System.String)">
            <summary>
            Conforms the file format using information in first line of file.
            </summary>
            <param name="firstLine">First line of file.</param>
            <returns>Whether file is in fasta format or not.</returns>
        </member>
        <member name="M:Bio.Matrix.SequenceToMatrixConversion.ConvertAlignedSequenceToSequence(System.Collections.Generic.IEnumerable{Bio.Algorithms.Alignment.ISequenceAlignment})">
            <summary>
            Converts Aligned Sequences to List of sequences.
            </summary>
            <param name="alignment">List of aligned sequences.</param>
            <returns>List of sequences.</returns>
        </member>
        <member name="P:Bio.Matrix.SequenceToMatrixConversion.ColumnType">
            <summary>
            Depicts whether output values will be binary or multistate(Discrete states).
            </summary>
        </member>
        <member name="P:Bio.Matrix.SequenceToMatrixConversion.MixtureSemanticsValue">
            <summary>
            Depicts output values in case of ambiguous characters.
            </summary>
        </member>
        <member name="T:Bio.Matrix.SparseMatrix`3">
            <summary>
            A matrix that internally represents only non-missing values. If most possible values are missing
            this saves memory. The trade off is that access is O(log(RowKeyCount)*log(ColKeyCount)) instead of being constant
            like the fastest dense methods.
            </summary>
            <typeparam name="TRowKey"></typeparam>
            <typeparam name="TColKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:Bio.Matrix.SparseMatrix`3.CreateEmptyInstance(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`1},`2)">
            <summary>
            Create SparseMatrix with all missing values.
            </summary>
            <param name="rowKeySequence">A sequence of row keys. The items will become the RowKeys of the Matrix.</param>
            <param name="colKeySequence">A sequence of colKeys. The items will come the ColKeys of the Matrix.</param>
            <param name="missingValue">The special value that represents missing</param>
            <returns>The empty SparseMatrix created.</returns>
        </member>
        <member name="M:Bio.Matrix.SparseMatrix`3.TryParseSparseFile(System.String,`2,System.Threading.Tasks.ParallelOptions,Bio.Matrix.Matrix{`0,`1,`2}@)">
            <summary>
            Tries to parse a file in sparse format and creates a SpareMatrix
            </summary>
            <param name="filename">The sparse file</param>
            <param name="missingValue">The special value that represents missing in the SparseMatrix</param>
            <param name="parallelOptions">A ParallelOptions instance that configures the multithreaded behavior of this operation.</param>
            <param name="matrix">The resulting matrix</param>
            <returns>true, if the file can be parsed; false, otherwise.</returns>
        </member>
        <member name="M:Bio.Matrix.SparseMatrix`3.TryParseSparseFile(System.IO.TextReader,`2,System.Threading.Tasks.ParallelOptions,Bio.Matrix.Matrix{`0,`1,`2}@)">
            <summary>
            Tries to parse a sparse textReader and creates a SpareMatrix
            </summary>
            <param name="textReader">The textReader stream in the sparse format</param>
            <param name="missingValue">The special value that represents missing in the SparseMatrix</param>
            <param name="parallelOptions">A ParallelOptions instance that configures the multithreaded behavior of this operation.</param>
            <param name="matrix">The resulting matrix</param>
            <returns>true, if the textReader can be parsed; false, otherwise.</returns>
        </member>
        <member name="T:Bio.Matrix.SparseMatrixExtensions">
            <summary>
            Extension methods on Matrix related to DenseAnsi.
            </summary>
        </member>
        <member name="M:Bio.Matrix.SparseMatrixExtensions.AsSparseMatrix``3(Bio.Matrix.Matrix{``0,``1,``2})">
            <summary>
            Converts matrix to a SparseMatrix. If matrix is already a SparseMatrix, then returns the given matrix without copying. 
            </summary>
            <param name="inputMatrix">The matrix to convert from</param>
            <returns>A SparseMatrix version of the matrix</returns>
        </member>
        <member name="M:Bio.Matrix.SparseMatrixExtensions.ToSparseMatrix``3(Bio.Matrix.Matrix{``0,``1,``2})">
            <summary>
            Converts matrix to a SparseMatrix. Even if the matrix is already an SparseMatrix, a new one is created.. 
            </summary>
            <param name="matrix">The matrix to convert from</param>
            <returns>A SparseMatrix version of the matrix</returns>
        </member>
        <member name="T:Bio.Matrix.TransposeView`3">
            <summary>
            A wrapper around a parent matrix that switches the rows with the columns.
            Because it is a view, any changes made to the values of this matrix or the parent matrix are reflected in both.
            </summary>
            <typeparam name="TRowKey">The type of the row key. Usually "String"</typeparam>
            <typeparam name="TColKey">The type of the col key. Usually "String"</typeparam>
            <typeparam name="TValue">The type of the value, for example, double, int, char, etc.</typeparam>
        </member>
        <member name="P:Bio.Matrix.TransposeView`3.ParentMatrix">
            <summary>
            The matrix that this view wraps.
            </summary>
        </member>
        <member name="T:Bio.Util.ArgumentParser.ArgumentCollection">
            <summary>
            Supports declarative and strongly typed parsing. Use Construct() to convert an argument collection to an instance of an object
            </summary>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Constructor.
            </summary>
            <param name="argList">Argument list.</param>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="lineToParse">Line to Parse.</param>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.ParseString(System.String)">
            <summary>
            Parse string Function.
            </summary>
            <param name="lineToParse">Line To parse.</param>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.CreateUsageString(System.Collections.Generic.IEnumerable{System.Reflection.MemberInfo},System.Reflection.MemberInfo,System.Type)">
            <summary>
            Create Usage String.
            </summary>
            <param name="requireds">Required member Info.</param>
            <param name="requiredParamsOrNull">Required Params or null.</param>
            <param name="constructingType">Constructing Type.</param>
            <returns></returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.ExtractSubtypeName(System.String@)">
            <summary>
            Extract Sub Type Name.
            </summary>
            <param name="lineToParse">Line To parse.</param>
            <returns>Sub Type Name.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.CreateArgList(System.String)">
            <summary>
            Create Argument List.
            </summary>
            <param name="lineToParse">Line To Parse.</param>
            <returns>List of Arguments.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.ExtractOptionalFlagInternal(System.String,System.Boolean)">
            <summary>
            Extract Optional Flag Internal.
            </summary>
            <param name="flag">The flag.</param>
            <param name="removeFlag">Remove Flag.</param>
            <returns>True if found.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.MatchesFlag(System.String,System.String)">
            <summary>
            Matches Flag.
            </summary>
            <param name="query">The query.</param>
            <param name="flagBase">Flag Base.</param>
            <returns>True if found.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.IsFlag(System.String)">
            <summary>
            Is flag.
            </summary>
            <param name="query">The Query.</param>
            <returns>True if found.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.CreateFlagString(System.String)">
            <summary>
            Create Flag String.
            </summary>
            <param name="flagBase">Flag Base.</param>
            <returns>True if found.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.AddOptionalFlag(System.String)">
            <summary>
            Add Optional Flag.
            </summary>
            <param name="argumentName">The argument Name.</param>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.ExtractOptionalFlag(System.String)">
            <summary>
            Extract Optional Flag.
            </summary>
            <param name="flag">The Flag.</param>
            <returns>True if found.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.PeekOptionalFlag(System.String)">
            <summary>
            Peek Optional Flag.
            </summary>
            <param name="flag">The Flag.</param>
            <returns></returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.ExtractOptional``1(System.String,``0)">
            <summary>
            Extract Optional.
            </summary>
            <typeparam name="T">Generic type.</typeparam>
            <param name="flag">The Flag.</param>
            <param name="defaultValue">Default Value.</param>
            <returns>The type of default value.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.PeekOptional``1(System.String,``0)">
            <summary>
            Peek Optional.
            </summary>
            <typeparam name="T">Generic Type.</typeparam>
            <param name="flag">The Flag.</param>
            <param name="defaultValue">Default Value.</param>
            <returns>The type of default value.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.ExtractOptionalInternal``1(System.String,``0,System.Boolean,System.String)">
            <summary>
            Extract Optional Internal.
            </summary>
            <typeparam name="T">Generic type.</typeparam>
            <param name="flag">The flag.</param>
            <param name="defaultValue">Default value.</param>
            <param name="removeFlagAndValue">Remove flag and value.</param>
            <param name="defaultParseArgsOrNull">Default Parse Arguments Or Null</param>
            <returns>The type of default value.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.ExtractAt``1(System.String,System.Int32)">
            <summary>
            Extract the argument name from position specified.
            </summary>
            <typeparam name="T">Generic type.</typeparam>
            <param name="argumentName">Argument Name.</param>
            <param name="argPosition">Argument position.</param>
            <returns>True if found.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.ExtractAtInternal``1(System.String,System.Int32,System.String,System.Boolean)">
            <summary>
            Extract At Internal.
            </summary>
            <typeparam name="T">Generic Type.</typeparam>
            <param name="argumentName">Argument Name.</param>
            <param name="argPosition">Argument position.</param>
            <param name="defaultParseArgsOrNull">Default Parse Argument Or Null.</param>
            <param name="removeValue">Remove value.</param>
            <returns>True if found.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.CheckThatEmpty">
            <summary>
            Check That Empty.
            </summary>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.CheckNoMoreOptions(System.Nullable{System.Int32},System.String)">
            <summary>
            Check for No More Options.
            </summary>
            <param name="numberOfRequiredArgumentsOrNull">Number Of Required Arguments Or Null.</param>
            <param name="parseObjectTypeOrNull">Parse Object Type Or Null.</param>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.ForceOptionalFlag(System.String)">
            <summary>
            Force Optional Flag.
            </summary>
            <param name="optionalFlag">Optional Flag.</param>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.ForceOptional``1(System.String,``0)">
            <summary>
            Force Optional.
            </summary>
            <typeparam name="T">Generic Type.</typeparam>
            <param name="argumentName">Argument Name.</param>
            <param name="argumentValue">Argument Value.</param>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.ExtractNext``1(System.String)">
            <summary>
            Extract Next Argument Name.
            </summary>
            <typeparam name="T">Generic Type.</typeparam>
            <param name="argumentName">Argument Name.</param>
            <returns>True if found.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.ContainsOptionalFlag(System.String)">
            <summary>
            Contains Optional Flag.
            </summary>
            <param name="flag">The flag.</param>
            <returns>True if contains optional flag.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.FindFlag(System.String)">
            <summary>
            Find if the Flag is present.
            </summary>
            <param name="flag">The Flag.</param>
            <returns>True if flag found.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.GetUnderlyingArray">
            <summary>
            Get Underlying Array.
            </summary>
            <returns>Argument List.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.Insert(System.Int32,System.String)">
            <summary>
            Insert argument name with specified index.
            </summary>
            <param name="idx">The Index.</param>
            <param name="argumentName">Argument Name.</param>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.Add(System.Object)">
            <summary>
            Add Argument to Argument List.
            </summary>
            <param name="argument">Argument to be added to list.</param>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.AddOptional(System.String,System.Object)">
            <summary>
            Add Optional.
            </summary>
            <param name="argumentName">Argument Name.</param>
            <param name="argumentValue">Argument Value.</param>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.Equals(System.Object)">
            <summary>
            Equals.
            </summary>
            <param name="obj">The object to be compared.</param>
            <returns>True if equal.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.GetHashCode">
            <summary>
            Get Hash Code.
            </summary>
            <returns>Hash Code.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.Clone">
            <summary>
            Copy of object.
            </summary>
            <returns>Clone of object.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.GetEnumerator">
            <summary>
            Enumerator of the Argument List.
            </summary>
            <returns>Enumerator of Argument list.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets enumerator.
            </summary>
            <returns>Enumerable Argument list.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.RemoveAt(System.Int32)">
            <summary>
            Removes arguments at specified index from Argument list.
            </summary>
            <param name="idx">The Index.</param>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.ConstructAndRun``1">
            <summary>
            Constructs T, then runs it. Catches Help and Parse exceptions and write's their messages to Console.Error. 
            All other exceptions are allowed to pass on through. Note that if a help exception is caught, the ExitCode
            will be set to 10022 (Operation canceled by user); if a parse exception is caught, the ExitCode is set
            to 1223 (Invalid argument). In either case, there is no apparent affect on the console, but the cluster
            will mark the task as failed.
            </summary>
            <typeparam name="T">A parsable type that implements IRunnable.</typeparam>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.Construct``1(System.Boolean,Bio.Util.ArgumentParser.ArgumentCollection)">
            <summary>
            Constructs an instance of type T from this ArgumentCollection. If SubtypeName is not null, will construct an instance 
            of the type SubtypeName, which is constructed by looking in all referenced assemblies for a type with the corresponding name.
            If SubtypeName is not a subtype of T, then an exception will be thrown. Whatever type is constructed must have a parameterless 
            constructor. Also, the type must have the //[Parsable] attribute. By default all of the type's public fields will be optional parameters. 
            Non-public fields can be marked as parsable, as can properties. Public fields can be hidden from parsing. Any field or property can 
            be marked as required. Mark fields as properties using the Parse attribute. The three Parse attributers are:
            [Parse(ParseAction.Optional)]  (mark as optional. public fields default to this)
            [Parse(ParseAction.Required)]  (mark as requried.)
            [Parse(ParseAction.Ignore)]    (ignore this public field. has no effect on non-public members or non-fields)
            </summary>
            <exception cref="T:Bio.Util.ArgumentParser.HelpException">HelpException is thrown if a help request is encountered. The message will contain the help string.</exception>
            <exception cref="T:Bio.Util.ArgumentParser.ParseException">ParseException is thrown if a type is not able to be parsed.</exception>
            <typeparam name="T">The type to construct. If SubtypeName is not null, will attempt to construct an instance of SubtypeName. If that is not 
            and instance of T, an exception will be thrown.</typeparam>
            <param name="checkComplete">If true, will make sure ArgumentCollection is empty when done parsing and will throw an exception if it is not.
            Set to false if you want to construct a class from ArgumentCollection and you expect arguments to be left over.</param>
            <param name="defaultArgsOrNull">defaultArgsOrNull</param> 
            <returns>Instance of type T from this ArgumentCollection.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.ParseInto``1(``0,System.Boolean,Bio.Util.ArgumentParser.ArgumentCollection)">
            <summary>
            Parses an instance of type T from this ArgumentCollection.
            </summary>
            <typeparam name="T">The type to Parse. If SubtypeName is not null, will attempt to Parse an instance of SubtypeName. If that is not 
            and instance of T, an exception will be thrown.</typeparam>
            <param name="parseResult">Parse Result.</param>
            <param name="checkComplete">If true, will make sure ArgumentCollection is empty when done parsing and will throw an exception if it is not.
            Set to false if you want to construct a class from ArgumentCollection and you expect arguments to be left over.</param>
            <param name="defaultArgsOrNull">Default Arguments Or Null.</param>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.AddDefaultArgsIfMissing(Bio.Util.ArgumentParser.ArgumentCollection)">
            <summary>
            Looks at all the flag-value pairs in defaultArgsOrNull and adds any to the current collection that are not already there.
            </summary>
            <param name="defaultArgsOrNull">Default Arguments Or Null.</param>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.HelpIsRequested">
            <summary>
            Help Is Requested.
            </summary>
            <returns>True if displayed.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.CreateInstance``1">
            <summary>
            Create an instance of type T.
            </summary>
            <typeparam name="T">The type to Create. If SubtypeName is not null, will attempt to Create an instance of SubtypeName. If that is not 
            and instance of T, an exception will be thrown.</typeparam>
            <returns>Created Instance.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.LoadRequiredParams(System.Object@,System.Reflection.MemberInfo)">
            <summary>
            Load Required Params.
            </summary>
            <param name="result">The result object.</param>
            <param name="requiredParamsArg">Required parameter argument.</param>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.LoadRequiredArguments(System.Object@,System.Reflection.MemberInfo@,System.Collections.Generic.IEnumerable{System.Reflection.MemberInfo},System.Boolean)">
            <summary>
            Load Required Params.
            </summary>
            <param name="result">The result object.</param>
            <param name="requiredParams">Required parameters.</param>
            <param name="requireds">List of required parameters.</param>
            <param name="checkComplete">Check Complete.</param>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.LoadOptionalArguments(System.Object@,System.Collections.Generic.IEnumerable{System.Reflection.MemberInfo})">
            <summary>
            Load Optional Params.
            </summary>
            <param name="result">The result object.</param>
            <param name="optionals">List of optional parameters.</param>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.TreatOptionAsFlag(System.Object,System.Reflection.MemberInfo)">
            <summary>
            Treat Option As Flag.
            </summary>
            <param name="defaultObject">Default Object.</param>
            <param name="member">The Member.</param>
            <returns></returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.LoadFlag(System.Object@,System.Reflection.MemberInfo)">
            <summary>
            Load Flag.
            </summary>
            <param name="result">The result object.</param>
            <param name="member">The member.</param>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.SetFieldOrPropertyValue(System.Object@,System.Reflection.MemberInfo,System.Object)">
            <summary>
            Set Field O rProperty Value.
            </summary>
            <param name="obj">The Object.</param>
            <param name="member">The Member.</param>
            <param name="value">Object Value.</param>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.ImplicitlyCastValueToType(System.Object,System.Type)">
            <summary>
            Implicitly Cast Value To Type.
            </summary>
            <param name="value">The Object Value.</param>
            <param name="destinationTypeOrNull">Destination Type Or Null.</param>
            <returns>Implicitly casted object.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.TryImplicitlyCastValueToType(System.Object,System.Type,System.Object@)">
            <summary>
            Try Implicitly Cast Value To Type.
            </summary>
            <param name="value">The Object Value.</param>
            <param name="destinationTypeOrNull">Destination Type Or Null.</param>
            <param name="result">The result object.</param>
            <returns>True if implicitly casted.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.GetFieldOrPropertyValue(System.Object,System.Reflection.MemberInfo)">
            <summary>
            Get Field Or Property Value.
            </summary>
            <param name="obj">The Object.</param>
            <param name="member">The Member.</param>
            <returns>Object that contains field or property value.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.GetActualParsingFieldOrPropertyType(System.Reflection.MemberInfo)">
            <summary>
            Get Actual Parsing Field Or Property Type.
            </summary>
            <param name="member">The Member.</param>
            <returns>Type of Parsing field or property.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.GetFieldOrPropertyType(System.Reflection.MemberInfo)">
            <summary>
            Get Field Or Property Type.
            </summary>
            <param name="memberInfo">Member info.</param>
            <returns>Type of field or property.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.LoadArgument(System.Object@,System.Reflection.MemberInfo,System.Boolean)">
            <summary>
            Load argument.
            </summary>
            <param name="result">The result object.</param>
            <param name="member">The member.</param>
            <param name="isOptional">Is Optional.</param>
            <returns>True if the value was loaded from the ArgumentCollection. False otherwise (only can be false if isOption is true)</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.GetParsableMembers(System.Type,System.Collections.Generic.List{System.Reflection.MemberInfo}@,System.Collections.Generic.List{System.Reflection.MemberInfo}@,System.Collections.Generic.List{System.Reflection.MemberInfo}@,System.Reflection.MemberInfo@)">
            <summary>
            Get Parsable Members.
            </summary>
            <param name="tType">Type of member.</param>
            <param name="optionals">Optional memberInfo.</param>
            <param name="requireds">List of required members.</param>
            <param name="constructingStrings">Constructing Strings Member.</param>
            <param name="requiredParams">Required Parameters.</param>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.PopulateFromParsableObject(System.Object,System.Boolean)">
            <summary>
            Populate From Parsable Object.
            </summary>
            <param name="obj">The Object.</param>
            <param name="suppressDefaults">Suppress Defaults.</param>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.TryValueAsCollectionString(System.Object@,System.Reflection.MemberInfo,System.Boolean)">
            <summary>
            Try Value As Collection String.
            </summary>
            <param name="value">The Value.</param>
            <param name="member">The Member.</param>
            <param name="suppressDefaults">Suppress Defaults.</param>
            <returns>True if value as collection string.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.TryValueAsCollectionString(System.Object@,System.Type,System.Type,System.Boolean)">
            <summary>
            Try Value As Collection String.
            </summary>
            <param name="value">The Value.</param>
            <param name="baseType">Base type.</param>
            <param name="parseTypeOrNull">Parse Type Or Null.</param>
            <param name="suppressDefaults">Suppress Defaults.</param>
            <returns>True if value as collection string.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.AddRequiredParamsToCollection(System.Object,System.Reflection.MemberInfo,System.Boolean)">
            <summary>
            Add Required Params To Collection.
            </summary>
            <param name="obj">The Object.</param>
            <param name="requiredParams">Required parameters.</param>
            <param name="suppressDefaults">Suppresses Defaults.</param>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.AddMemberToCollection(System.Object@,System.Object,System.Reflection.MemberInfo,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Add Member To Collection.
            </summary>
            <param name="defaultObjOrNull">Default Object Or Null.</param>
            <param name="obj">The Object.</param>
            <param name="member">The Member.</param>
            <param name="isOptional">Is Optional.</param>
            <param name="suppressDefaults">Suppress Defaults.</param>
            <param name="labelRequireds">Required params Label.</param>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.CreateHelpMessage(System.Type,System.Boolean)">
            <summary>
            Create Help Message.
            </summary>
            <param name="t">Type passed to create help message.</param>
            <param name="includeDateStamp">Include Date Stamp.</param>
            <returns>Created Help exception.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.CreateHelpMessage``1(System.Boolean)">
            <summary>
            Create Help Message.
            </summary>
            <typeparam name="T">Help message type.</typeparam>
            <param name="includeDateStamp">Include Date Stamp</param>
            <returns>Created Help exception.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.CreateHelpMessage(System.Object,System.Boolean)">
            <summary>
             Create Help Message.
            </summary>
            <param name="defaultInstance">Default instance of object.</param>
            <param name="includeDateStamp">Include Date Stamp if set to true.</param>
            <returns>Created Help exception.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.GetXmlDocumentation(System.Type,System.Xml.Linq.XDocument)">
            <summary>
            Get Xml Documentation.
            </summary>
            <param name="type">Type of doc.</param>
            <param name="xmlDoc">Xml document.</param>
            <returns></returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.GetXmlDocumentation(System.Reflection.MemberInfo,System.Xml.Linq.XDocument)">
            <summary>
            Get Xml Documentation.
            </summary>
            <param name="member">The member.</param>
            <param name="xmlDoc">Xml Doc.</param>
            <returns>Xml Documentation.</returns>
        </member>
        <member name="F:Bio.Util.ArgumentParser.ArgumentCollection._doubleNewLineRegEx">
            <summary>
            Double New Line RegEx.
            </summary>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.GetXmlDocumentation(System.String,System.Xml.Linq.XDocument)">
            <summary>
            Get Xml Documentation.
            </summary>
            <param name="xmlTagName">Xml Tag Name.</param>
            <param name="xmlDoc">Xml Doc.</param>
            <returns>Xml Documentation.</returns>
        </member>
        <member name="F:Bio.Util.ArgumentParser.ArgumentCollection.xmlDocumentCache">
            <summary>
            Xml Document Cache.
            </summary>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.LoadXmlCodeDocumentationFile(System.Type)">
            <summary>
            Load Xml Code Documentation File.
            </summary>
            <param name="type">Type of Doc.</param>
            <returns>Xml document.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.CreateHelpMessage(System.Object,System.Reflection.MemberInfo,System.Boolean)">
            <summary>
            Create Help Message.
            </summary>
            <param name="defaultInstance">Default Instance.</param>
            <param name="member">the Member.</param>
            <param name="isOption">Is Option flag.</param>
            <returns>Created Help Message.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.CheckForHelp``1(System.String)">
            <summary>
            Check For Help.
            </summary>
            <typeparam name="T">Type for check for help.</typeparam>
            <param name="value">Value for Check for help.</param>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.GetHelpOnKnownSubtypes(System.Type,System.Boolean)">
            <summary>
            Get Help On Known Subtypes.
            </summary>
            <param name="type">Type of Help exception.</param>
            <param name="includeDateStamp">Optional Include Date Stamp.</param>
            <returns>Help Exception.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.EnumerateValuesOfTypeFromParsable``1(System.Object)">
            <summary>
            Enumerate Values Of Type From Parsable.
            </summary>
            <typeparam name="T">Type of Parsable.</typeparam>
            <param name="values">The Values.</param>
            <returns>List of types.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentCollection.EnumerateValuesOfTypeFromParsable``1(System.Object,System.Type)">
            <summary>
            Enumerate Values Of Type From Parsable.
            </summary>
            <typeparam name="T">Type of Parsable.</typeparam>
            <param name="values">The Values.</param>
            <param name="parseTypeOfObj">parse Type Of Obj.</param>
            <returns>List of types.</returns>
        </member>
        <member name="P:Bio.Util.ArgumentParser.ArgumentCollection.SubtypeName">
            <summary>
            SubtypeName
            </summary>
        </member>
        <member name="P:Bio.Util.ArgumentParser.ArgumentCollection.GenerateHelpPage">
            <summary>
            True/False whether to generate help page
            </summary>
        </member>
        <member name="P:Bio.Util.ArgumentParser.ArgumentCollection.Count">
            <summary>
            Count in Argument List.
            </summary>
        </member>
        <member name="P:Bio.Util.ArgumentParser.ArgumentCollection.FlagValuePairs">
            <summary>
            Enumerates all flag-value pairs. In case in which there are back to back flags, the first flag is enumerated with null as the value.
            </summary>
        </member>
        <member name="T:Bio.Util.ArgumentParser.ArgumentValueType">
            <summary>
            Command Line Argument value types.
            </summary>
        </member>
        <member name="F:Bio.Util.ArgumentParser.ArgumentValueType.String">
            <summary>
            String type argument.
            </summary>
        </member>
        <member name="F:Bio.Util.ArgumentParser.ArgumentValueType.OptionalString">
            <summary>
            String type argument.
            </summary>
        </member>
        <member name="F:Bio.Util.ArgumentParser.ArgumentValueType.Int">
            <summary>
            Integer type argument.
            </summary>
        </member>
        <member name="F:Bio.Util.ArgumentParser.ArgumentValueType.OptionalInt">
            <summary>
            Integer type data. Used for optional parameter.
            </summary>
        </member>
        <member name="F:Bio.Util.ArgumentParser.ArgumentValueType.Bool">
            <summary>
            Boolean type argument.
            </summary>
        </member>
        <member name="F:Bio.Util.ArgumentParser.ArgumentValueType.MultipleInts">
            <summary>
            Inidicates that integer value may be specified more than once.
            Only valid if the argument is a collection.
            </summary>
        </member>
        <member name="F:Bio.Util.ArgumentParser.ArgumentValueType.MultipleUniqueStrings">
            <summary>
            Inidicates that string value may be specified more than once.
            If duplicate values are found an exception is raised.
            </summary>
        </member>
        <member name="T:Bio.Util.ArgumentParser.ArgumentType">
            <summary>
            Used to control parsing of command line arguments. 
            </summary>
        </member>
        <member name="F:Bio.Util.ArgumentParser.ArgumentType.Optional">
            <summary>
            Indicates that argument is not required.
            </summary>
        </member>
        <member name="F:Bio.Util.ArgumentParser.ArgumentType.Required">
            <summary>
            Indicates that the argument is mandatory.
            </summary>
        </member>
        <member name="F:Bio.Util.ArgumentParser.ArgumentType.DefaultArgument">
            <summary>
            Indicates the arugment is the default. If the parameter name is not found this param
            </summary>
        </member>
        <member name="T:Bio.Util.ArgumentParser.CommandLineArguments">
            <summary>
            This class parses all the command line arguments.
            </summary>
        </member>
        <member name="F:Bio.Util.ArgumentParser.CommandLineArguments.parsedArguments">
            <summary>
            All the parameters and values passed from commandline are stored after parsing.
            </summary>
        </member>
        <member name="F:Bio.Util.ArgumentParser.CommandLineArguments.enumerator">
            <summary>
            The Command Line enumerator.
            </summary>
        </member>
        <member name="F:Bio.Util.ArgumentParser.CommandLineArguments.paramNameAliasMap">
            <summary>
            Contains the mapping between parameter name and the alias (shortName).
            </summary>
        </member>
        <member name="F:Bio.Util.ArgumentParser.CommandLineArguments.targetObject">
            <summary>
            The target object to which the command line arguments are to be set.
            </summary>
        </member>
        <member name="F:Bio.Util.ArgumentParser.CommandLineArguments.argumentList">
            <summary>
            All the required and optional parameters from commandline are stored.
            </summary>
        </member>
        <member name="M:Bio.Util.ArgumentParser.CommandLineArguments.#ctor">
            <summary>
            Initializes a new instance of the CommandLineArguments class.
            </summary>
        </member>
        <member name="M:Bio.Util.ArgumentParser.CommandLineArguments.Parameter(Bio.Util.ArgumentParser.ArgumentType,System.String,Bio.Util.ArgumentParser.ArgumentValueType,System.String,System.String)">
            <summary>
            Defines the argument that the commandline utility supports.
            </summary>
            <param name="argType">Argument type.</param>
            <param name="parameterName">Name of the parameter.</param>
            <param name="argValueType">Defines the argument value type (int or string or bool) for the argument.</param>
            <param name="shortName">ShortName or alias for the argument.</param>
            <param name="helpDesc">Description of the argument.</param>
        </member>
        <member name="M:Bio.Util.ArgumentParser.CommandLineArguments.Parse(System.String[],System.Object)">
            <summary>
            Parses the command line arguments passed from the utility.
            </summary>
            <param name="arguments">Arguments to be parsed.</param>
            <param name="destination">Resulting parsed arguments.</param>
        </member>
        <member name="M:Bio.Util.ArgumentParser.CommandLineArguments.GetEnumerator">
            <summary>
            Returns a enumerator which walks through the dictionary of found parameters.
            </summary>
            <returns>Enumerator of dictionary of found parameters.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.CommandLineArguments.MoveNext">
            <summary>
            Sets the enumerator to the next found parameter.
            </summary>
            <returns>true if there is a next found parameter, else false.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.CommandLineArguments.Reset">
            <summary>
            Resets the enumerator to the initial position in front of the first found parameter.
            </summary>
        </member>
        <member name="M:Bio.Util.ArgumentParser.CommandLineArguments.GetMismatchPosition(System.String,System.String)">
            <summary>
            Returns the position of the mismatch of arguments.
            </summary>
            <param name="regExpr">Regular expression used for matching.</param>
            <param name="srchExpr">Expression to be searched.</param>
            <returns>Returns the character position where there is a mismatch.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.CommandLineArguments.EncodeValue(System.String)">
            <summary>
            Encode Value.
            </summary>
            <param name="value">The Value.</param>
            <returns>The Encoded Value.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.CommandLineArguments.ParseValue(System.Type,System.String,System.Object@)">
            <summary>
            Parse Value.
            </summary>
            <param name="type">The Type of value.</param>
            <param name="stringData">String Data.</param>
            <param name="value">The object Value.</param>
            <returns>True if value parsed.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.CommandLineArguments.AssignTargetObjectProperties">
            <summary>
            Assign Target Object Properties.
            </summary>
        </member>
        <member name="M:Bio.Util.ArgumentParser.CommandLineArguments.Parse(System.String)">
            <summary>
            Parses the command line arguments passed from the utility.
            </summary>
            <exception cref="T:Bio.Util.ArgumentParser.ArgumentParserException">Thrown when any error is found during parsing.</exception>
            <param name="arguments">Arguments passed via command line utility.</param>
        </member>
        <member name="M:Bio.Util.ArgumentParser.CommandLineArguments.AddParsedParameter(System.String,System.String)">
            <summary>
            Adds the parsed parameter and the value to the parsed argument list.
            </summary>
            <param name="paramName">The new parameter which is to be added to FoundParameters.</param>
            <param name="paramValue">Value which corresponds to NewParam.</param>
        </member>
        <member name="M:Bio.Util.ArgumentParser.CommandLineArguments.CheckRequiredParameters">
            <summary>
            Check if the values for required parameters are passed or not.
            </summary>
        </member>
        <member name="P:Bio.Util.ArgumentParser.CommandLineArguments.AllowAdditionalArguments">
            <summary>
            Gets or sets a value indicating whether additional arguments are reqiured or not.
            </summary>
        </member>
        <member name="P:Bio.Util.ArgumentParser.CommandLineArguments.ArgumentSeparator">
            <summary>
            Gets or sets the argument separator character.
            </summary>
        </member>
        <member name="P:Bio.Util.ArgumentParser.CommandLineArguments.Current">
            <summary>
            Gets the current found parameter from enumerator.
            </summary>
        </member>
        <member name="P:Bio.Util.ArgumentParser.CommandLineArguments.System#Collections#IEnumerator#Current">
            <summary>
            Gets current value from enumerator.
            </summary>
        </member>
        <member name="T:Bio.Util.ArgumentParser.CommandLineArguments.Argument">
            <summary>
            This class saves the details of a single argument.
            </summary>
        </member>
        <member name="T:Bio.Util.ArgumentParser.ArgumentParserException">
            <summary>
            Base class for Command line Argument Exceptions.
            </summary>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentParserException.#ctor">
            <summary>
            Argument Parser Exception.
            </summary>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentParserException.#ctor(System.String)">
            <summary>
            Argument Parser Exception.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentParserException.#ctor(System.String,System.Exception)">
            <summary>
            Argument Parser Exception.
            </summary>
            <param name="message">The message.</param>
            <param name="innerException">Inner Exception.</param>
        </member>
        <member name="T:Bio.Util.ArgumentParser.ArgumentSyntaxException">
            <summary>
            The exception that is thrown when there is syntax error.
            </summary>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentSyntaxException.#ctor">
            <summary>
            Argument Syntax Exception.
            </summary>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentSyntaxException.#ctor(System.String)">
            <summary>
            Argument Syntax Exception.
            </summary>
            <param name="message">The Message.</param>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentSyntaxException.#ctor(System.String,System.Exception)">
            <summary>
            Argument Syntax Exception.
            </summary>
            <param name="message">The Message.</param>
            <param name="innerException">Inner Exception.</param>
        </member>
        <member name="T:Bio.Util.ArgumentParser.RequiredArgumentMissingException">
            <summary>
            The exception that is thrown when Required parameter is not passed in the command line
            </summary>
        </member>
        <member name="M:Bio.Util.ArgumentParser.RequiredArgumentMissingException.#ctor">
            <summary>
            Required Argument Missing Exception.
            </summary>
        </member>
        <member name="M:Bio.Util.ArgumentParser.RequiredArgumentMissingException.#ctor(System.String)">
            <summary>
            Required Argument Missing Exception.
            </summary>
            <param name="message">The Message.</param>
        </member>
        <member name="M:Bio.Util.ArgumentParser.RequiredArgumentMissingException.#ctor(System.String,System.Exception)">
            <summary>
            Required Argument Missing Exception.
            </summary>
            <param name="message">The Message.</param>
            <param name="innerException">Inner Exception.</param>
        </member>
        <member name="T:Bio.Util.ArgumentParser.InvalidArgumentValueException">
            <summary>
            This exception is thrown when an invalid value is passed to the parameter.
            </summary>
        </member>
        <member name="M:Bio.Util.ArgumentParser.InvalidArgumentValueException.#ctor">
            <summary>
            Invalid Argument Value Exception.
            </summary>
        </member>
        <member name="M:Bio.Util.ArgumentParser.InvalidArgumentValueException.#ctor(System.String)">
            <summary>
            Invalid Argument Value Exception.
            </summary>
            <param name="message">The Message.</param>
        </member>
        <member name="M:Bio.Util.ArgumentParser.InvalidArgumentValueException.#ctor(System.String,System.Exception)">
            <summary>
            Invalid Argument Value Exception.
            </summary>
            <param name="message">The Message.</param>
            <param name="innerException"></param>
        </member>
        <member name="T:Bio.Util.ArgumentParser.DuplicateArgumentValueException">
            <summary>
            This exception is thrown when an duplicate value is passed to the array type parameter.
            </summary>
        </member>
        <member name="M:Bio.Util.ArgumentParser.DuplicateArgumentValueException.#ctor">
            <summary>
            Duplicate Argument Value Exception.
            </summary>
        </member>
        <member name="M:Bio.Util.ArgumentParser.DuplicateArgumentValueException.#ctor(System.String)">
            <summary>
            Duplicate Argument Value Exception.
            </summary>
            <param name="message">The Message.</param>
        </member>
        <member name="M:Bio.Util.ArgumentParser.DuplicateArgumentValueException.#ctor(System.String,System.Exception)">
            <summary>
            Duplicate Argument Value Exception.
            </summary>
            <param name="message">The Message.</param>
            <param name="innerException">Inner Exception.</param>
        </member>
        <member name="T:Bio.Util.ArgumentParser.ArgumentRepeatedException">
            <summary>
            This exception is thrown when the same parameter is passed more than once.
            </summary>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentRepeatedException.#ctor">
            <summary>
            Argument Repeated Exception.
            </summary>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentRepeatedException.#ctor(System.String)">
            <summary>
            Argument Repeated Exception.
            </summary>
            <param name="message">The Message.</param>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentRepeatedException.#ctor(System.String,System.Exception)">
            <summary>
            Argument Repeated Exception.
            </summary>
            <param name="message">The Message.</param>
            <param name="innerException">Inner Exception.</param>
        </member>
        <member name="T:Bio.Util.ArgumentParser.ArgumentNullValueException">
            <summary>
            This exception is thrown when passed arguments (other than boolean type arguments) does not hold values.
            </summary>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentNullValueException.#ctor">
            <summary>
            Argument Null Value Exception.
            </summary>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentNullValueException.#ctor(System.String)">
            <summary>
            Argument Null Value Exception.
            </summary>
            <param name="message">The Message.</param>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentNullValueException.#ctor(System.String,System.Exception)">
            <summary>
            Argument Null Value Exception.
            </summary>
            <param name="message">The Message.</param>
            <param name="innerException">Inner Exception.</param>
        </member>
        <member name="T:Bio.Util.ArgumentParser.ArgumentNotFoundException">
            <summary>
            This exception is raised when a parameter is not defined but passed in cmdline.
            </summary>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentNotFoundException.#ctor">
            <summary>
            Argument Not Found Exception.
            </summary>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentNotFoundException.#ctor(System.String)">
            <summary>
            Argument Not Found Exception.
            </summary>
            <param name="message">The Message.</param>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ArgumentNotFoundException.#ctor(System.String,System.Exception)">
            <summary>
            Argument Not Found Exception.
            </summary>
            <param name="message">The Message.</param>
            <param name="innerException">Inner Exception.</param>
        </member>
        <member name="T:Bio.Util.ArgumentParser.CommandArguments">
            <summary>
            Command line arguments take the form:
            <code>
            -flag 1 ... -option1 value -option2 value ... required1 required 2
            </code>
            Note that the presence of the flag indicates that the optional value is true.
            Note also that required arguments can be named, in which case they can be in any order.
            </summary>
        </member>
        <member name="M:Bio.Util.ArgumentParser.CommandArguments.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Bio.Util.ArgumentParser.CommandArguments.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="args"></param>
        </member>
        <member name="M:Bio.Util.ArgumentParser.CommandArguments.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Constructor.
            </summary>
            <param name="args"></param>
        </member>
        <member name="M:Bio.Util.ArgumentParser.CommandArguments.ConstructAndRun``1(System.String[])">
            <summary>
            Constructs and instance of T, then runs it. This convenience method creates an instance of CommandArguments, then
            call ConstructAndRun on that result.
            </summary>
            <typeparam name="T">A //[Parsable] type that implements IExecutable.</typeparam>
            <param name="commandArgs">Command line arguments.</param>
        </member>
        <member name="M:Bio.Util.ArgumentParser.CommandArguments.ConstructAndRun``1(System.String[],System.Boolean)">
            <summary>
            Constructs and instance of T, then runs it. This convenience method creates an instance of CommandArguments, then
            call ConstructAndRun on that result.
            </summary>
            <typeparam name="T">A //[Parsable] type that implements IExecutable.</typeparam>
            <param name="commandArgs">Command line arguments.</param>
            <param name="generateHelpPage">True/False whether to generate help or throw HelpException</param>
        </member>
        <member name="M:Bio.Util.ArgumentParser.CommandArguments.Construct``1(System.String[])">
            <summary>
            Simple wrapper that constructs an instance of type T from the command line array. 
            See ArgumentCollection.Construct() for documentation.
            </summary>
            <typeparam name="T">The Parsable type to be constructed</typeparam>
            <param name="commandArgs">The string array from which to construct</param>
            <returns>The fully instantiated object</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.CommandArguments.Construct``1(System.String)">
            <summary>
            Simple wrapper that constructs an instance of type T from the command line string. 
            See ArgumentCollection.Construct() for documentation.
            </summary>
            <typeparam name="T">The Parsable type to be constructed</typeparam>
            <param name="commandString">The string from which to construct</param>
            <returns>The fully instantiated object</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.CommandArguments.FromParsable(System.Object)">
            <summary>
            Constructs and instance of CommandArguments from a parsable object. This is the inverse of Construct().
            Will include all default arguments.
            </summary>
            <param name="obj">The object from which to construct the ConstructorArguments</param>
            <returns>The result</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.CommandArguments.FromParsable(System.Object,System.Boolean)">
            <summary>
            Constructs and instance of CommandArguments from a parsable object. This is the inverse of Construct().
            </summary>
            <param name="obj">The object from which to construct the ConstructorArguments</param>
            <param name="suppressDefaults">Specifies whether values that are equal to the defaults should be included in the resulting ArgumentCollection</param>
            <returns>The result</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.CommandArguments.ToString(System.Object,System.Boolean,System.Boolean)">
            <summary>
            Shortcut for CommandArguments.FromParsable(obj).ToString().  Note that Construct(ToString(obj)) == obj.
            </summary>
            <param name="parsableObject">An obejct with the //[Parsable] attribute.</param>
            <param name="suppressDefaults">Specifies whether values that are equal to the defaults should be included in the resulting ArgumentCollection</param>
            <param name="protectWithQuotes">protectWithQuotes</param>
            <returns>A Command string that could be used to reconstruct parsableObject.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.CommandArguments.CreateUsageString(System.Collections.Generic.IEnumerable{System.Reflection.MemberInfo},System.Reflection.MemberInfo,System.Type)">
            <summary>
            Create Usage String.
            </summary>
            <param name="requireds">Required members.</param>
            <param name="requiredParamsOrNull">Required Params Or Null.</param>
            <param name="constructingType">Constructing Type.</param>
            <returns>Created Usage String.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.CommandArguments.ExtractSubtypeName(System.String@)">
            <summary>
            Extract Subtype Name.
            </summary>
            <param name="lineToParse">Line To Parse.</param>
            <returns>Extracted Subtype Name.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.CommandArguments.CreateArgList(System.String)">
            <summary>
            Create Argument List.
            </summary>
            <param name="lineToParse">Line To Parse.</param>
            <returns>Created Argument List.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.CommandArguments.ExtractOptionalFlagInternal(System.String,System.Boolean)">
            <summary>
            Extract Optional Flag Internal.
            </summary>
            <param name="flag">The Flag.</param>
            <param name="removeFlag">Remove flag or Not.</param>
            <returns>True if extracted Optional Flag Internal.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.CommandArguments.MatchesFlag(System.String,System.String)">
            <summary>
            Matches Flag.
            </summary>
            <param name="query">The Query.</param>
            <param name="flagBase">The Flag Base.</param>
            <returns>True if Matches Flag.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.CommandArguments.IsFlag(System.String)">
            <summary>
            Is Flag.
            </summary>
            <param name="query">The Query.</param>
            <returns>True if flag set.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.CommandArguments.CreateFlagString(System.String)">
            <summary>
            Create Flag String.
            </summary>
            <param name="flagBase">The Flag Base.</param>
            <returns>Created Flag String.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.CommandArguments.AddOptionalFlag(System.String)">
            <summary>
            Add Optional Flag.
            </summary>
            <param name="argumentName">The argumentName.</param>
        </member>
        <member name="M:Bio.Util.ArgumentParser.CommandArguments.ToString(System.Boolean)">
            <summary>
            To String for Argument list.
            </summary>
            <param name="protectWithQuotes">Protect With Quotes optional.</param>
            <returns>String form of Argument list. </returns>
        </member>
        <member name="T:Bio.Util.ArgumentParser.ConstructorArguments">
            <summary>
            Constructor arguments take the form:
            <code>
            (option1:value,option2:value,...,req1,req2...)
            </code>
            Optionally, the opening paren can be preceded by a class name. For example:
            <code>
            LogisticRegression(option1:value,option2:value,...,req1,req2...)
            </code>
            This class name specifies what will be constructed when the Construct() method is called. Note that flags are treated
            exactly like options. So a boolean flag called verbose would be set using verbose:true. Note also that required
            arguments can be named, in which case they can be in any order.
            </summary>
        </member>
        <member name="F:Bio.Util.ArgumentParser.ConstructorArguments.ArgumentDelimiter">
            <summary>
            Argument Delimiter.
            </summary>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ConstructorArguments.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ConstructorArguments.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="args">The Arguments.</param>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ConstructorArguments.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Constructor.
            </summary>
            <param name="args">The Arguments.</param>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ConstructorArguments.ConstructAndRun``1(System.String[])">
            <summary>
            Constructs and instance of T, then runs it. This convenience method creates an instance of CommandArguments, then
            call ConstructAndRun on that result.
            </summary>
            <typeparam name="T">A //[Parsable] type that implements IExecutable.</typeparam>
            <param name="commandArguments">Constructor arguments</param>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ConstructorArguments.ConstructAndRun``1(System.String)">
            <summary>
            Constructs and instance of T, then runs it. This convenience method creates an instance of CommandArguments, then
            call ConstructAndRun on that result.
            </summary>
            <typeparam name="T">A //[Parsable] type that implements IExecutable.</typeparam>
            <param name="constructorString">Constructor arguments</param>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ConstructorArguments.Construct``1(System.String)">
            <summary>
            Simple wrapper that constructs an instance of type T from the command string. 
            See ArgumentCollection.Construct() for documentation.
            </summary>
            <typeparam name="T">The Parsable type to be constructed</typeparam>
            <param name="commandString">The string from which to construct</param>
            <returns>The fully instantiated object</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ConstructorArguments.FromParsable(System.Object,System.Type,System.Boolean)">
            <summary>
            Constructs and instance of ConstructorArguments from a parsable object. This is the inverse of Construct().
            Note: will always set SubtypeName to the Type of object.
            </summary>
            <param name="obj">The object from which to construct the ConstructorArguments</param>
            <param name="parseTypeOrNull">parseTypeOrNull</param>
            <param name="suppressDefaults">Specifies whether values that are equal to the defaults should be included in the resulting ArgumentCollection</param>
            <returns>The result</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ConstructorArguments.ToString(System.Object,System.Boolean)">
            <summary>
            Shortcut for ConstructorArguments.FromParsable(obj).ToString().  Note that Construct(ToString(obj)) == obj.
            </summary>
            <param name="parsableObject">An obejct with the //[Parsable] attribute.</param>
            <param name="suppressDefaults">Specifies whether values that are equal to the defaults should be included in the resulting ArgumentCollection</param>
            <returns>A Constructor string that could be used to reconstruct parsableObject.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ConstructorArguments.CreateUsageString(System.Collections.Generic.IEnumerable{System.Reflection.MemberInfo},System.Reflection.MemberInfo,System.Type)">
            <summary>
            Create Usage String.
            </summary>
            <param name="requireds">Required members.</param>
            <param name="requiredParamsOrNull">Required Params Or Null.</param>
            <param name="constructingType">Constructing Type.</param>
            <returns>Created Usage String.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ConstructorArguments.ExtractSubtypeName(System.String@)">
            <summary>
            Extract Subtype Name.
            </summary>
            <param name="lineToParse">Line To Parse.</param>
            <returns>Extracted Subtype Name.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ConstructorArguments.CreateArgList(System.String)">
            <summary>
            Create Argument List.
            </summary>
            <param name="constructorArgsAsString">Constructor Args As String.</param>
            <returns>Created Argument List.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ConstructorArguments.AddOptionalFlag(System.String)">
            <summary>
            Add Optional Flag.
            </summary>
            <param name="argumentName">Argument Name.</param>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ConstructorArguments.CreateFlagString(System.String)">
            <summary>
            Create Flag String.
            </summary>
            <param name="flagBase">The flag Base.</param>
            <returns>Created Flag String.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ConstructorArguments.MatchesFlag(System.String,System.String)">
            <summary>
            Matches Flag.
            </summary>
            <param name="query">The Query.</param>
            <param name="flagBase">The Flag base.</param>
            <returns>True if flag matches.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ConstructorArguments.IsFlag(System.String)">
            <summary>
            Is Flag.
            </summary>
            <param name="query">The Query.</param>
            <returns>True if flag is set.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ConstructorArguments.ExtractOptionalFlagInternal(System.String,System.Boolean)">
            <summary>
            Extract Optional Flag Internal.
            </summary>
            <param name="flag">The Flag.</param>
            <param name="removeFlag">Remove flag or Not.</param>
            <returns>True if Extract Optional Flag Internal.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ConstructorArguments.ToString">
            <summary>
            To String for Argument list.
            </summary>
            <returns>String form of Argument list.</returns>
        </member>
        <member name="T:Bio.Util.ArgumentParser.HelpException">
            <summary>
            HelpException
            </summary>
        </member>
        <member name="M:Bio.Util.ArgumentParser.HelpException.#ctor(System.String,System.Boolean)">
            <summary>
            Constructor.
            </summary>
            <param name="message">The Message.</param>
            <param name="includeDateStamp">Include Date Stamp Optional.</param>
        </member>
        <member name="M:Bio.Util.ArgumentParser.HelpException.#ctor(System.String,System.Object[])">
            <summary>
            Constructor.
            </summary>
            <param name="messageFormat">The Message Format.</param>
            <param name="args">Argument list.</param>
        </member>
        <member name="M:Bio.Util.ArgumentParser.HelpException.FormatMessage(System.String,System.Boolean)">
            <summary>
            Format Message.
            </summary>
            <param name="message">The message.</param>
            <param name="includeDateStamp">Include Date Stamp Optional.</param>
            <returns>Formatted Message.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.HelpException.GetDateCompiledString">
            <summary>
            Get Date Compiled String.
            </summary>
            <returns>DateCompiledString.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.HelpException.IndentString(System.Int32,System.Int32)">
            <summary>
            Indent String.
            </summary>
            <param name="indents">Indents size.</param>
            <param name="indentWidth">Indent width.</param>
            <returns>Indent String.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.HelpException.Tokens(System.String)">
            <summary>
            Tokens inside passed string.
            </summary>
            <param name="str">String passed.</param>
            <returns>List of tokens inside string.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.HelpException.KnownTag(System.String)">
            <summary>
            Known Tag.
            </summary>
            <param name="tag">Tag passed.</param>
            <returns>True if found.</returns>
        </member>
        <member name="P:Bio.Util.ArgumentParser.HelpException.RawMessage">
            <summary>
            Raw Message.
            </summary>
        </member>
        <member name="T:Bio.Util.ArgumentParser.InputFile">
            <summary>
            Convertible to and from type FileInfo. Verifies that the file exists.
            </summary>
        </member>
        <member name="T:Bio.Util.ArgumentParser.ParsableFile">
            <summary>
            ParsableFile
            </summary>
        </member>
        <member name="F:Bio.Util.ArgumentParser.ParsableFile._fileInfo">
            <summary>
            File Info.
            </summary>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ParsableFile.ToString">
            <summary>
            FileInfo ToString conversion.
            </summary>
            <returns>String of fileInfo.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ParsableFile.op_Implicit(Bio.Util.ArgumentParser.ParsableFile)~System.IO.FileInfo">
            <summary>
            Convert FileInfo to Parsable File.
            </summary>
            <param name="inputFile">Input file.</param>
            <returns>Converted FileInfo to Parsable File.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ParsableFile.op_Implicit(System.IO.FileInfo)~Bio.Util.ArgumentParser.ParsableFile">
            <summary>
            Convert Parsable File to FileInfo.
            </summary>
            <param name="fileInfo">FileInfo.</param>
            <returns>Converted Parsable File to FileInfo.</returns>
        </member>
        <member name="P:Bio.Util.ArgumentParser.ParsableFile.FullName">
            <summary>
            Can set with a short file name, but the 'get' will return the FullName;
            </summary>
        </member>
        <member name="T:Bio.Util.ArgumentParser.IParsable">
            <summary>
            IParsable interface.
            </summary>
        </member>
        <member name="M:Bio.Util.ArgumentParser.IParsable.FinalizeParse">
            <summary>
            FinalizeParse
            </summary>
        </member>
        <member name="M:Bio.Util.ArgumentParser.InputFile.FinalizeParse">
            <summary>
            Finalize Parse.
            </summary>
        </member>
        <member name="M:Bio.Util.ArgumentParser.InputFile.op_Implicit(Bio.Util.ArgumentParser.InputFile)~System.IO.FileInfo">
            <summary>
            Convert fileInfo to input file.
            </summary>
            <param name="inputFile">Input file.</param>
            <returns>Converted operator.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.InputFile.op_Implicit(System.IO.FileInfo)~Bio.Util.ArgumentParser.InputFile">
            <summary>
            Convert input file to FileInfo type.
            </summary>
            <param name="fileInfo">File Info.</param>
            <returns>>Converted fileInfo to input file..</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.InputFile.op_Implicit(Bio.Util.ArgumentParser.InputFile)~Bio.IO.NamedStreamCreator">
            <summary>
            Convert NamedStreamcreator to InputFile type.
            </summary>
            <param name="inputFile">Input File.</param>
            <returns>Converted NamedStreamCreator to InputFile.</returns>
        </member>
        <member name="T:Bio.Util.ArgumentParser.IRunnable">
            <summary>
            IRunnable interface.
            </summary>
        </member>
        <member name="M:Bio.Util.ArgumentParser.IRunnable.Run">
            <summary>
            Run
            </summary>
        </member>
        <member name="T:Bio.Util.ArgumentParser.OutputFile">
            <summary>
            Convertible to and from type FileInfo. Creates the output directory, if needed.
            </summary>
        </member>
        <member name="M:Bio.Util.ArgumentParser.OutputFile.FinalizeParse">
            <summary>
            Finalize Parse.
            </summary>
        </member>
        <member name="M:Bio.Util.ArgumentParser.OutputFile.op_Implicit(Bio.Util.ArgumentParser.OutputFile)~System.IO.FileInfo">
            <summary>
            Convert File Info to Output File type.
            </summary>
            <param name="outputFile">OutPut File.</param>
            <returns>Converted File Info to Output File type.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.OutputFile.op_Implicit(System.IO.FileInfo)~Bio.Util.ArgumentParser.OutputFile">
            <summary>
            Convert Output File to File Info type.
            </summary>
            <param name="fileInfo">File Info.</param>
            <returns>Converted Output File to File Info type.</returns>
        </member>
        <member name="T:Bio.Util.ArgumentParser.ParallelOptionsParser">
            <summary>
            ParallelOptionsParser
            </summary>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ParallelOptionsParser.op_Implicit(Bio.Util.ArgumentParser.ParallelOptionsParser)~System.Threading.Tasks.ParallelOptions">
            <summary>
            Convert Parallel options to Parallel options Parser type.
            </summary>
            <param name="parser">Parallel options Parser.</param>
            <returns> Converted Parallel options to Parallel options Parser type.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ParallelOptionsParser.op_Implicit(System.Threading.Tasks.ParallelOptions)~Bio.Util.ArgumentParser.ParallelOptionsParser">
            <summary>
            Convert Parallel options Parser to Parallel options type.
            </summary>
            <param name="parallelOptions">Parallel Options.</param>
            <returns>Converted Parallel options Parser to Parallel options type.</returns>
        </member>
        <member name="P:Bio.Util.ArgumentParser.ParallelOptionsParser.MaxDegreeOfParallelism">
            <summary>
            Max Degree Of Parallelism.
            </summary>
        </member>
        <member name="T:Bio.Util.ArgumentParser.ParseAction">
            <summary>
            ParseAction
            </summary>
        </member>
        <member name="F:Bio.Util.ArgumentParser.ParseAction.Required">
            <summary>
            Specifies that a field is required when parsing.
            </summary>
        </member>
        <member name="F:Bio.Util.ArgumentParser.ParseAction.Optional">
            <summary>
            Specifies that an element is optional. Note that all public fields are optional by default. This allows you to mark private or protected fields as parsable
            </summary>
        </member>
        <member name="F:Bio.Util.ArgumentParser.ParseAction.Ignore">
            <summary>
            Specifies that a field should not be parsed. This only is useful for public fields that would otherwise be automatically parsed.
            </summary>
        </member>
        <member name="F:Bio.Util.ArgumentParser.ParseAction.ArgumentString">
            <summary>
            Specifies that the string used to construct this argument should be stored here. Note that this MUST be of type string.
            </summary>
        </member>
        <member name="F:Bio.Util.ArgumentParser.ParseAction.Params">
            <summary>
            Behaves like the params keyword for methods: sucks up all the final arguments and constructs a list out of them. They must all be the same type, as
            specified by the type of the list that this attribute is attached to. This can only be placed on a member of type List. This is considered an optional
            argument, in the sense that if there are no arguments left, an empty list will be returned. It's up to the parsable type to decide if it wants to check
            that the list is non-empty in its FinalizeParse method.
            </summary>
        </member>
        <member name="T:Bio.Util.ArgumentParser.ParseAttribute">
            <summary>
            Parse Attribute class.
            </summary>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ParseAttribute.#ctor(Bio.Util.ArgumentParser.ParseAction)">
            <summary>
            Constructor.
            </summary>
            <param name="action">Parse Action.</param>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ParseAttribute.#ctor(Bio.Util.ArgumentParser.ParseAction,System.Type)">
            <summary>
            Constructor.
            </summary>
            <param name="action">Parse Action.</param>
            <param name="parseType">Parse type.</param>
        </member>
        <member name="P:Bio.Util.ArgumentParser.ParseAttribute.Action">
            <summary>
            Parse Action.
            </summary>
        </member>
        <member name="P:Bio.Util.ArgumentParser.ParseAttribute.ParseTypeOrNull">
            <summary>
             Parse Type Or Null.
            </summary>
        </member>
        <member name="P:Bio.Util.ArgumentParser.ParseAttribute.DefaultParameters">
            <summary>
            Use ConstructorArguments syntax to hard code settings.
            </summary>
        </member>
        <member name="T:Bio.Util.ArgumentParser.ParseAsNonCollectionAttribute">
            <summary>
            Labels a Collection type as not being parsed as a collection.
            </summary>
        </member>
        <member name="T:Bio.Util.ArgumentParser.DoNotParseInheritedAttribute">
            <summary>
            Marks a class so that only fields and properties that have explicit Parse attributes SET IN THE CURRENT CLASS OR A DERIVED CLASS will be parsed.
            </summary>
        </member>
        <member name="T:Bio.Util.ArgumentParser.ParseExtensions">
            <summary>
            Parse Extensions class.
            </summary>
        </member>
        <member name="F:Bio.Util.ArgumentParser.ParseExtensions.DefaultOptionalAttribute">
            <summary>
            Default Optional Attribute.
            </summary>
        </member>
        <member name="F:Bio.Util.ArgumentParser.ParseExtensions.DefaultIgnoreAttribute">
            <summary>
            Default Ignore Attribute
            </summary>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ParseExtensions.DoNotParseInherited(System.Type)">
            <summary>
            Determines if the ParseExplicit attribute has been set.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ParseExtensions.GetParseTypeOrNull(System.Reflection.MemberInfo)">
            <summary>
            Get Parse Type Or Null.
            </summary>
            <param name="member">The Member.</param>
            <returns>Type of Parse.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ParseExtensions.GetDefaultParametersOrNull(System.Reflection.MemberInfo)">
            <summary>
            Get Default Parameters Or Null.
            </summary>
            <param name="member">The Member.</param>
            <returns>Default Parameter or null.</returns>
        </member>
        <member name="F:Bio.Util.ArgumentParser.ParseExtensions._parseAttributeCache">
            <summary>
            Parse Attribute Cache.
            </summary>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ParseExtensions.GetParseAttribute(System.Reflection.MemberInfo,System.Type[])">
            <summary>
            Get Parse Attribute.
            </summary>
            <param name="member">The Member.</param>
            <param name="actualTypeInheritanceHierarchy">Actual Type Inheritance Hierarchy.</param>
            <returns>Parse Attribute.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ParseExtensions.GetParseAttributeInternal(System.Reflection.MemberInfo,System.Type[])">
            <summary>
            Gets the default or declared parse attribute for the specified member.
            </summary>
            <param name="member">The Member.</param>
            <param name="actualTypeInheritanceHierarchy">actualTypeInheritanceHierarchy</param>
            <returns>Parse Attribute.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ParseExtensions.IsIndexer(System.Reflection.MemberInfo)">
            <summary>
            Is Indexer.
            </summary>
            <param name="member">The Member.</param>
            <returns>Member Indexer.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ParseExtensions.IsConstructable(System.Type)">
            <summary>
            Returns true if and only if the type has a public default constructor, or is an interface or abstract class, in which case a derived type may be parsed.
            </summary>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ParseExtensions.HasPublicDefaultConstructor(System.Type)">
            <summary>
            Has Public Default Constructor.
            </summary>
            <param name="t">Type of default constructor.</param>
            <returns>True if it has public default constructor.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ParseExtensions.IsCollection``1(System.Type)">
            <summary>
            Is collection.
            </summary>
            <typeparam name="T">Generic Type.</typeparam>
            <param name="type">Type of interface.</param>
            <returns>True if interface type matches.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ParseExtensions.IsCollection(System.Type)">
            <summary>
             Is collection.
            </summary>
            <param name="type">Type of interface.</param>
            <returns>True if interface type matches.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ParseExtensions.ParseAsCollection(System.Type)">
            <summary>
            Parse As Collection.
            </summary>
            <param name="parseType">Parse type.</param>
            <returns>True if parse as collection.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ParseExtensions.GetInheritanceHierarchy(System.Type)">
            <summary>
            Get Inheritance Hierarchy.
            </summary>
            <param name="type">Type</param>
            <returns>List of types.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ParseExtensions.ToParseString(System.Object,System.Type,System.Boolean)">
            <summary>
            To Parse String.
            </summary>
            <param name="obj">The Object.</param>
            <param name="parseTypeOrNull">Parse Type Or Null.</param>
            <param name="suppressDefaults">Suppress Defaults</param>
            <returns></returns>
        </member>
        <member name="T:Bio.Util.ArgumentParser.ParseException">
            <summary>
            Parse Exception class.
            </summary>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ParseException.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ParseException.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="message">The Message.</param>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ParseException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">The Message.</param>
            <param name="innerException">Inner exception.</param>
        </member>
        <member name="M:Bio.Util.ArgumentParser.ParseException.#ctor(System.String,System.Object[])">
            <summary>
            Constructor.
            </summary>
            <param name="message">The Message.</param>
            <param name="args">The Arguments.</param>
        </member>
        <member name="T:Bio.Util.ArgumentParser.Parser">
            <summary>
            Parser Class.
            </summary>
        </member>
        <member name="M:Bio.Util.ArgumentParser.Parser.HasParseMethod(System.Type)">
            <summary>
            Checks if this type has a Parse or TryParse static method that takes a string as the argument. 
            </summary>
            <param name="type">The Type.</param>
            <returns>True if has parsed method properly.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.Parser.TryParseAll``1(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IList{``0}@)">
            <summary>
            Try Parse All.
            </summary>
            <typeparam name="T">Generic Type.</typeparam>
            <param name="values">The Values.</param>
            <param name="result">The List result.</param>
            <returns>True if Parsed all.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.Parser.ParseAll``1(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Parse All.
            </summary>
            <typeparam name="T">Generic type.</typeparam>
            <param name="values">The Values.</param>
            <returns>List of Parsed types.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.Parser.Parse(System.String,System.Type)">
            <summary>
            This method should be updated to use the rest of the methods in this class.
            </summary>
            <param name="field">the Field.</param>
            <param name="type">Type.</param>
            <returns>Parsed Object.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.Parser.Parse``1(System.String)">
            <summary>
            Will parse s into T, provided T has a Parse(string) or TryParse(string s, out T t) method defined, or is one of the magical
            special cases we've implemented (including ICollection (comma delimited), Nullable and Enums).
            </summary>
            <typeparam name="T"></typeparam>
            <param name="text"></param>
            <returns></returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.Parser.TryParse``1(System.String,``0@)">
            <summary>
            Will parse s into T, provided T has a Parse(string) or TryParse(string s, out T t) method defined, or is one of the magical
            special cases we've implemented (including ICollection (comma delimited), Nullable and Enums).
            </summary>
            <typeparam name="T">T</typeparam>
            <param name="s">s</param>
            <param name="t">t</param>
            <returns>bool</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.Parser.NullableTryParse``1(System.String,``0@)">
            <summary>
            Nullable Try Parse.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="s"></param>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.Parser.StringTryParse``1(System.String,``0@)">
            <summary>
            String Try Parse.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="s"></param>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.Parser.CollectionsTryParse``1(System.String,``0@)">
            <summary>
            Collections Try Parse.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="s"></param>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.Parser.GenericCollectionsTryParse``2(System.String,``0@)">
            <summary>
            Generic Collections Try Parse.
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="S"></typeparam>
            <param name="s"></param>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.Parser.EnumTryParse``1(System.String,``0@)">
            <summary>
            Enum Try Parse.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="s"></param>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.Parser.GenericTryParse``1(System.String,``0@)">
            <summary>
            Generic Try Parse.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="s"></param>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="T:Bio.Util.ArgumentParser.Parser.GenericParser`1">
            <summary>
            Generic Parser class.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Bio.Util.ArgumentParser.Parser.GenericParser`1.IsParsable">
            <summary>
            Is Parsable.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.Parser.GenericParser`1.TryParse(System.String,`0@)">
            <summary>
            Try Parse.
            </summary>
            <param name="s"></param>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="T:Bio.Util.ArgumentParser.TypeExtensions">
            <summary>
            Type Extensions.
            </summary>
        </member>
        <member name="M:Bio.Util.ArgumentParser.TypeExtensions.ToTypeString(System.Type)">
            <summary>
            To Type String.
            </summary>
            <param name="type">Type.</param>
            <returns>To type String.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.TypeExtensions.GetEnumNames(System.Type)">
            <summary>
            Get Enum Names.
            </summary>
            <param name="type">Type.</param>
            <returns>Array of Enum Names.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.TypeExtensions.GetImplementingTypes(System.Type)">
            <summary>
            Get Implementing Types.
            </summary>
            <param name="interfaceType">Interface type.</param>
            <returns>List of type.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.TypeExtensions.GetDerivedTypes(System.Type)">
            <summary>
            Get Derived Types.
            </summary>
            <param name="classType">Class Type.</param>
            <returns>List of type.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.TypeExtensions.Implements(System.Type,System.Type)">
            <summary>
            Implements.
            </summary>
            <param name="type">Type.</param>
            <param name="interfaceType">InterFace type.</param>
            <returns>True if Implements.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.TypeExtensions.IsSubclassOfOrImplements(System.Type,System.Type)">
            <summary>
            Is Subclass Of Or Implements.
            </summary>
            <param name="type">Type.</param>
            <param name="baseType">Base Type.</param>
            <returns>True if Subclass Of Or Implements.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.TypeExtensions.IsInstanceOf(System.Type,System.Type)">
            <summary>
            Tests if typeOne is an instance of testType. Same as IsSubclassOfOrImplements, but also checks for equality.
            </summary>
            <param name="typeOne">Type One.</param>
            <param name="testType">Test Type.</param>
            <returns>True if found to be is instance of.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.TypeExtensions.GetPropertiesOfType(System.Type,System.Type)">
            <summary>
            Get Properties Of Type.
            </summary>
            <param name="type">type.</param>
            <param name="propertyType">Property type.</param>
            <returns>List of Property Info.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.TypeExtensions.GetFieldsOfType(System.Type,System.Type)">
            <summary>
            Get Fields Of Type.
            </summary>
            <param name="type">Type.</param>
            <param name="fieldType">Field type.</param>
            <returns>List of field Info.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.TypeExtensions.GetFieldsAndPropertiesOfType(System.Type,System.Type)">
            <summary>
            Get Fields And Properties Of Type.
            </summary>
            <param name="type">The type.</param>
            <param name="memberType">Member type.</param>
            <returns>List of Member Info.</returns>
        </member>
        <member name="T:Bio.Util.ArgumentParser.TypeFactory">
            <summary>
            Type Factory.
            </summary>
        </member>
        <member name="F:Bio.Util.ArgumentParser.TypeFactory.allReferencedAssemblies">
            <summary>
            All Referenced Assemblies.
            </summary>
        </member>
        <member name="F:Bio.Util.ArgumentParser.TypeFactory.TypeNameAndBaseNameToType">
            <summary>
            Type Name And BaseName To Type.
            </summary>
        </member>
        <member name="M:Bio.Util.ArgumentParser.TypeFactory.TryGetType(System.String,System.Type,System.Type@)">
            <summary>
            Returns the first type in any of the referenced assemblies that matches the type name. If typeName includes the namespace, 
            then matches on the fully qualified name. Else, looks for the first type in any of namespaces
            that matches typeName AND is a subtype of baseType (use typeof(object) as a default).
            </summary>
            <param name="typeName">The type name we're searching for. May either be fully qualified or contain only the class name</param>
            <param name="baseType">Will only return a type that is a subtype of baseType</param>
            <param name="returnType">The type matching typeName, if found, or null.</param>
            <returns>true iff the typeName could be resolved into a type.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.TypeFactory.TryGetTypeInternal(System.String,System.Type,System.Type@)">
            <summary>
            Try Get Type Internal.
            </summary>
            <param name="typeName">Type Name.</param>
            <param name="baseType">Base type.</param>
            <param name="returnType">Return type.</param>
            <returns>True if Gets type internal.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.TypeFactory.GetType(System.Reflection.Assembly,System.Type,System.String,System.Type[])">
            <summary>
            Returns the first type in assembly that matches the type name. If typeName includes the namespace, 
            then matches on the fully qualified name. Else, looks for the first type in any of Assembly's namespaces
            that matches typeName
            </summary>
            <param name="assembly">The assembly in which to search</param>
            <param name="baseType">Will only return a type that is a subtype of baseType</param>
            <param name="typeName">The type name we're searching for. May either be fully qualified or contain only the class name</param>
            <param name="genericTypes">genericTypes</param>
            <returns>The type, if found, or null.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.TypeFactory.GetReferencedTypes">
            <summary>
            Get Referenced Types.
            </summary>
            <returns>List of type.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.TypeFactory.GetAssemblyTypes(System.Reflection.Assembly)">
            <summary>
            Get Assembly Types.
            </summary>
            <param name="assembly">Assembly</param>
            <returns>List of type.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.TypeFactory.TryGetGenericParameters(System.String@,System.Type[]@)">
            <summary>
            Checks to see if the type name is generic. If so, modifies the typeName and tries to construct the generic type arguments. 
            </summary>
            <param name="typeName">The type name. Will be modified if generic.</param>
            <param name="genericTypes">List of generic types. Null if this type is not generic.</param>
            <returns>True if there was no problem parsing. False is there is a problem.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.TypeFactory.EnumerateAllUserAssemblyCodeBases">
            <summary>
            Enumerate AllUser Assembly CodeBases.
            </summary>
            <returns>List of Assembly.</returns>
        </member>
        <member name="M:Bio.Util.ArgumentParser.TypeFactory.EnumerateReferencedSystemAssemblies(System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
            <summary>
            Enumerate Referenced SystemAssemblies.
            </summary>
            <param name="userAssemblies">User Assemblies.</param>
            <returns></returns>
        </member>
        <member name="P:Bio.Util.ArgumentParser.TypeFactory.AllReferencedAssemblies">
            <summary>
            All Referenced Assemblies.
            </summary>
        </member>
        <member name="T:Bio.Util.CounterWithMessages">
            <summary>
            Writes messages to the console every so many increments.
            </summary>
        </member>
        <member name="M:Bio.Util.CounterWithMessages.#ctor(System.String,System.Int32,System.Nullable{System.Int32})">
            <summary>
            Create a counter that will output messages to the console every so many increments. Incrementing is thread-safe.
            </summary>
            <param name="formatStringWithOneOrTwoPlaceholders">A format string with containing at least {0} and, optionally, {1}.</param>
            <param name="messageInterval">How often messages should be output, in increments.</param>
            <param name="totalCountOrNull">The total number of increments, or null if not known.</param>
            <returns>A counter</returns>
        </member>
        <member name="M:Bio.Util.CounterWithMessages.#ctor(System.String,System.Int32,System.Nullable{System.Int32},System.Boolean)">
            <summary>
            Create a counter that will output messages to the console every so many increments. Incrementing is thread-safe.
            </summary>
            <param name="formatStringWithOneOrTwoPlaceholders">A format string with containing at least {0} and, optionally, {1}.</param>
            <param name="messageInterval">How often messages should be output, in increments.</param>
            <param name="totalCountOrNull">The total number of increments, or null if not known.</param>
            <param name="quiet">if true, doesn't output to the console.</param>
            <returns>A counter</returns>
        </member>
        <member name="M:Bio.Util.CounterWithMessages.Increment">
            <summary>
            Increment the counter by one. Incrementing is thread-safe.
            </summary>
        </member>
        <member name="P:Bio.Util.CounterWithMessages.Index">
            <summary>
            The number of increments so far.
            </summary>
        </member>
        <member name="P:Bio.Util.CounterWithMessages.Quiet">
            <summary>
            If true, doesn't send any messages to the console; just counts.
            </summary>
        </member>
        <member name="T:Bio.Util.Distribute.CommandApp">
            <summary>
            Utility for distributing an arbitrary command.
            </summary>
        </member>
        <member name="T:Bio.Util.Distribute.SelfDistributable">
            <summary>
                Convince base class for classes that wish to be executed from the command line with a -Distribute option for
                submitting to cluster.
            </summary>
        </member>
        <member name="T:Bio.Util.Distribute.IDistributable">
            <summary>
            An interface specifying that an object can be distributed in a delightfully parallel way.
            </summary>
        </member>
        <member name="M:Bio.Util.Distribute.IDistributable.RunTasks(Bio.Util.RangeCollection,System.Int64)">
            <summary>
            Will run a subset of tasks.
            </summary>
            <param name="taskCount">Total number of pieces into which work will be divided.</param>
            <param name="tasksToRun">The pieces that should be run.</param>
        </member>
        <member name="M:Bio.Util.Distribute.IDistributable.Cleanup(System.Int64)">
            <summary>
            Called when all tasks are complete.
            </summary>
        </member>
        <member name="M:Bio.Util.Distribute.IDistributable.Cancel">
            <summary>
            Will be called when the user enters CTRL+C. This is the signal from the cluster when a job is canceled. 
            If you do not wish to implement, then create an empty function. 
            Note that this will be called by an external thread, and when you return, your job will be canceled. 
            If you need some time, call System.Threading.Thread.Sleep(15 *1000) before returning, which will cause it to sleep
            for 15 seconds (your grace period before the cluster kills the task.
            An example of something to do: set a cancel flag in your loop so that if Cancel is called, you exit out of your loop
            and your result file is properly flushed and disposed. More advanced: serialize your current object graph so you can
            recover where you left off.
            </summary>
        </member>
        <member name="P:Bio.Util.Distribute.IDistributable.JobName">
            <summary>
            The name of the job if submitted to the cluster.
            </summary>
        </member>
        <member name="M:Bio.Util.Distribute.SelfDistributable.RunTasks(Bio.Util.RangeCollection,System.Int64)">
            <summary>
                Run tasks.
            </summary>
            <param name="tasksToRun">Tasks To Run.</param>
            <param name="taskCount">Task Count.</param>
        </member>
        <member name="M:Bio.Util.Distribute.SelfDistributable.Cleanup(System.Int64)">
            <summary>
                Cleanup.
            </summary>
            <param name="taskCount">Task Count.</param>
        </member>
        <member name="M:Bio.Util.Distribute.SelfDistributable.Cancel">
            <summary>
                A do-nothing implementation.
            </summary>
        </member>
        <member name="M:Bio.Util.Distribute.SelfDistributable.Run">
            <summary>
                Run.
            </summary>
        </member>
        <member name="P:Bio.Util.Distribute.SelfDistributable.Distribute">
            <summary>
                How to distribute this object.
            </summary>
        </member>
        <member name="P:Bio.Util.Distribute.SelfDistributable.JobName">
            <summary>
                The name
            </summary>
        </member>
        <member name="M:Bio.Util.Distribute.CommandApp.RunTasks(Bio.Util.RangeCollection,System.Int64)">
            <summary>
            Run Tasks.
            </summary>
            <param name="tasksToRun">Tasks to Run.</param>
            <param name="taskCount">Task Count.</param>
        </member>
        <member name="M:Bio.Util.Distribute.CommandApp.Cleanup(System.Int64)">
            <summary>
            Cleanup.
            </summary>
            <param name="taskCount">Task Count.</param>
        </member>
        <member name="P:Bio.Util.Distribute.CommandApp.ExeName">
            <summary>
            Executable Name.
            </summary>
        </member>
        <member name="P:Bio.Util.Distribute.CommandApp.CommandArgs">
            <summary>
            Command Args.
            </summary>
        </member>
        <member name="T:Bio.Util.Distribute.IDistribute">
            <summary>
            An interface that describes an object that can distribute something of type IDistributable.
            </summary>
        </member>
        <member name="M:Bio.Util.Distribute.IDistribute.Distribute(Bio.Util.Distribute.IDistributable)">
            <summary>
            Run the work on this distributableObject
            </summary>
            <param name="distributableObject">Distributable Object.</param>
        </member>
        <member name="T:Bio.Util.Distribute.Locally">
            <summary>
            Runs tasks locally.
            </summary>
        </member>
        <member name="F:Bio.Util.Distribute.Locally.taskCount">
            <summary>
            Task count.
            </summary>
        </member>
        <member name="F:Bio.Util.Distribute.Locally.tasks">
            <summary>
            Range Collection tasks.
            </summary>
        </member>
        <member name="F:Bio.Util.Distribute.Locally.parallelOptions">
            <summary>
            Parallel options.
            </summary>
        </member>
        <member name="F:Bio.Util.Distribute.Locally.cleanup">
            <summary>
            cleanUp.
            </summary>
        </member>
        <member name="M:Bio.Util.Distribute.Locally.Distribute(Bio.Util.Distribute.IDistributable)">
            <summary>
            Runs Tasks locally on distributableObject.
            </summary>
            <param name="distributableObject">The object that will run the tasks.</param>
        </member>
        <member name="M:Bio.Util.Distribute.Locally.FinalizeParse">
            <summary>
            Finalize Parse.
            </summary>
        </member>
        <member name="P:Bio.Util.Distribute.Locally.TaskCount">
            <summary>
            How many pieces should the work be divided into?
            </summary>
        </member>
        <member name="P:Bio.Util.Distribute.Locally.Tasks">
            <summary>
            The set of Tasks that should be run by this instance
            </summary>
        </member>
        <member name="P:Bio.Util.Distribute.Locally.Cleanup">
            <summary>
            Specifies whether cleanup should be run when this task is complete.
            </summary>
        </member>
        <member name="P:Bio.Util.Distribute.Locally.ParallelOptions">
            <summary>
            Specifies the local parallel options
            </summary>
        </member>
        <member name="T:Bio.Util.Distribute.RaiseError">
            <summary>
            For objects that shouldn't self distribute
            </summary>
        </member>
        <member name="M:Bio.Util.Distribute.RaiseError.Distribute(Bio.Util.Distribute.IDistributable)">
            <summary>
            Distribute.
            </summary>
            <param name="distributableObject"></param>
        </member>
        <member name="M:Bio.Util.Distribute.RaiseError.FinalizeParse">
            <summary>
            Finalize Parse.
            </summary>
        </member>
        <member name="T:Bio.Util.ParallelOptionsScope">
            <summary>
                ParallelOptionsScope
            </summary>
        </member>
        <member name="F:Bio.Util.ParallelOptionsScope.SingleThreadedOptions">
            <summary>
                A ParallelOptions instance in which MaxDegreeOfParallelism is 1.
            </summary>
        </member>
        <member name="F:Bio.Util.ParallelOptionsScope.FullyParallelOptions">
            <summary>
                A ParallelOptions instance in which MaxDegreeOfParallelism is equal to the number of cores in the current
                environment.
            </summary>
        </member>
        <member name="M:Bio.Util.ParallelOptionsScope.Dispose">
            <summary>
                Dispose
            </summary>
        </member>
        <member name="M:Bio.Util.ParallelOptionsScope.Create(System.Int32)">
            <summary>
                Creates a new ParallelOptionsScope using the specified thread count and defaults for all other options. Must be
                used in a using statement.
            </summary>
        </member>
        <member name="M:Bio.Util.ParallelOptionsScope.Create(System.Threading.Tasks.ParallelOptions)">
            <summary>
                Creates a new ParallelOptionsScope using the specified options. Must be used in a using statement.
            </summary>
        </member>
        <member name="M:Bio.Util.ParallelOptionsScope.CreateSingleThreaded">
            <summary>
                Creates a new ParallelOptionsScope that specified that a single thread should be used. Must be used in a using
                statement.
            </summary>
        </member>
        <member name="M:Bio.Util.ParallelOptionsScope.CreateFullyParallel">
            <summary>
                Creates a new ParallelOptionsScope that sets the number of threads to be equal to the number of cores in the
                current environment. Must be used in a using statement.
            </summary>
        </member>
        <member name="M:Bio.Util.ParallelOptionsScope.Suspend">
            <summary>
                Suspend
            </summary>
            <returns></returns>
        </member>
        <member name="P:Bio.Util.ParallelOptionsScope.Exists">
            <summary>
                Exists
            </summary>
        </member>
        <member name="P:Bio.Util.ParallelOptionsScope.Current">
            <summary>
                Current
            </summary>
        </member>
        <member name="T:Bio.Util.ParallelQueryExtensions">
            <summary>
                ParallelQueryExtensions
            </summary>
        </member>
        <member name="M:Bio.Util.ParallelQueryExtensions.WithParallelOptionsScope``1(System.Linq.ParallelQuery{``0})">
            <summary>
                ParallelQuery
            </summary>
            <typeparam name="TSource">TSource</typeparam>
            <param name="source">source</param>
            <returns>ParallelQuery</returns>
        </member>
        <member name="T:Bio.Util.SpecialFunctions">
            <summary>
            SpecialFunctions
            </summary>
        </member>
        <member name="M:Bio.Util.SpecialFunctions.GetEntryOrCallingAssembly">
            <summary>
            GetEntryOrCallingAssembly
            </summary>
            <returns>Assembly</returns>
        </member>
        <member name="M:Bio.Util.SpecialFunctions.VersionToDate(System.Version)">
            <summary>
            VersionToDate
            </summary>
            <param name="version">version</param>
            <returns>DateTime</returns>
        </member>
        <member name="M:Bio.Util.SpecialFunctions.DateProgramWasCompiled">
            <summary>
            Returns the date and time that the Assembly that the program started in was compiled. Note that the time never includes daylight savings.
            In order to work, you must set [assembly: AssemblyVersion("1.0.*")] in AssemblyInfo.cs.  This can be done either manually or by
            editing Assembly Information in the project's Properties.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Bio.Util.SpecialFunctions.DivideWork``1(System.Collections.Generic.IEnumerable{``0},Bio.Util.RangeCollection,System.Int64,System.Int64,Bio.Util.RangeCollection)">
            <summary>
            This method will spread out the work items--like dealing cards around the table, you only get every other K'th card,
            where K is the number of people, when batchCount=1. (Or else you get sets of batchCount-contiguous cards).
            </summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable"></param>
            <param name="pieceIndexRangeCollection"></param>
            <param name="pieceCount"></param>
            <param name="batchCount"></param>
            <param name="skipListOrNull"></param>
            <returns>The item and it's original index in the enumerable.</returns>
        </member>
        <member name="M:Bio.Util.SpecialFunctions.CopyDirectory(System.String,System.String,System.Boolean)">
            <summary>
            CopyDirectory
            </summary>
            <param name="oldDirectoryName">oldDirectoryName</param>
            <param name="newDirectoryName">newDirectoryName</param>
            <param name="recursive">recursive</param>
        </member>
        <member name="M:Bio.Util.SpecialFunctions.CopyDirectory(System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            CopyDirectory
            </summary>
            <param name="oldDirectoryName">oldDirectoryName</param>
            <param name="newDirectoryName">newDirectoryName</param>
            <param name="recursive">recursive</param>
            <param name="laterDateOnly">laterDateOnly</param>
        </member>
        <member name="T:Bio.Util.StatusChangedEventArgs">
            <summary>
            Class to hold status changed message.
            </summary>
        </member>
        <member name="M:Bio.Util.StatusChangedEventArgs.#ctor">
            <summary>
            Initializes a new instance of the StatusChangedEventArgs class.
            </summary>
        </member>
        <member name="M:Bio.Util.StatusChangedEventArgs.#ctor(System.String)">
            <summary>
            Initializes a new instance of the StatusChangedEventArgs class with the specified message.
            </summary>
            <param name="statusMessage">Status message.</param>
        </member>
        <member name="P:Bio.Util.StatusChangedEventArgs.StatusMessage">
            <summary>
            Gets or sets the status message.
            </summary>
        </member>
        <member name="T:Bio.IO.BAM.BAMSort">
            <summary>
            Class implements sorting in a SequenceAlignmentMap.
            Sorts the data in "SequenceAlignmentMap" By
             ChromosomeCoordinates
             Or
             ReadNames
            </summary>
        </member>
        <member name="F:Bio.IO.BAM.BAMSort.SortedListMaxCount">
            <summary>
            Maximum limit of sorted bucket.
            Write the list to file once the limit is reached.
            The max count number is an optimized value based on local tests.
            </summary>
        </member>
        <member name="F:Bio.IO.BAM.BAMSort.sequenceAlignMap">
            <summary>
            Holds SequenceAlignmentMap object to be sorted.
            </summary>
        </member>
        <member name="F:Bio.IO.BAM.BAMSort.sortField">
            <summary>
            Type of sort needed.
            </summary>
        </member>
        <member name="M:Bio.IO.BAM.BAMSort.#ctor(Bio.IO.SAM.SequenceAlignmentMap,Bio.IO.BAM.BAMSortByFields)">
            <summary>
            Default Constructor
            Initializes a new instance of the BAMSorter class
            </summary>
            <param name="seqAlignMap">SequenceAlignmentMap object to be sorted.</param>
            <param name="sortType">Type of sort required.</param>
        </member>
        <member name="M:Bio.IO.BAM.BAMSort.Sort">
            <summary>
            Sorts the SequenceAlignmentMap based on the sort by fields,
            either chromosome coordinates or read names and retuns sorted BAM indexer
            </summary>
            <example>
            1. Sort by chromosome name.
            BAMSort sorter = new BAMSort([SequenceAlignmentMap], BAMSortByFields.ChromosomeCoordinates);
            IList&lt;BAMSortedIndex&gt; sortedGroups = sorter.Sort();
            foreach (BAMSortedIndex sortedGroup in sortedGroups)
            {
                sortedGroup.GroupName // Containes the RName
                foreach (int index in sortedGroup)
                {
                    index // index of SequenceAlignmentMap.QuerySequences 
                }
            }
            2. Sort by read name.
            BAMSort sorter = new BAMSort([SequenceAlignmentMap], BAMSortByFields.ChromosomeCoordinates);
            IList&lt;BAMSortedIndex&gt; sortedGroups = sorter.Sort();
            foreach (int index in sortedGroups[0]) // There will be only Group in list.
            {
                index // index of SequenceAlignmentMap.QuerySequences 
            }
            </example>
            <returns>sorted BAM indexer</returns>
        </member>
        <member name="M:Bio.IO.BAM.BAMSort.SortByReadNames">
            <summary>
            Sort the index of SequenceAlignmentMap by QName.
            Fill the index (sorted by QName) into a list, when the list size reaches
            the maximum limit, write the list to file and clear the list.
            </summary>
        </member>
        <member name="M:Bio.IO.BAM.BAMSort.SortByChromosomeCoordinates">
            <summary>
            Sort the index of SequenceAlignmentMap by RName then by Pos.
            Fill the index (sorted by RName then by Pos) into a list, when the list size reaches
            the maximum limit, write the list to file and clear the list.
            </summary>
        </member>
        <member name="M:Bio.IO.BAM.BAMSort.WriteToFile(System.Collections.Generic.SortedList{System.Object,System.String})">
            <summary>
            Creates a file in Temp folder.
            Write the data in SortedList to a file.
            Returns the filename
            </summary>
            <param name="sortedList">List to be written to file.</param>
            <returns>File name.</returns>
        </member>
        <member name="T:Bio.IO.BAM.BAMSortedIndex">
            <summary>
            This class implements indexer for Sorted BAM Index.
            Reads
             Index for a file (contains data sorted by index) and return index
             Or
             Indices from multiple file (contains data sorted by index in each file) and returns smallest index.
            </summary>
        </member>
        <member name="F:Bio.IO.BAM.BAMSortedIndex.readers">
            <summary>
            List of file readers.
            </summary>
        </member>
        <member name="F:Bio.IO.BAM.BAMSortedIndex.data">
            <summary>
            Next data object to processed in each file.
            </summary>
        </member>
        <member name="F:Bio.IO.BAM.BAMSortedIndex.sortedFilenames">
            <summary>
            holds filenames (sorted files) like chr1_1, chr1_2, chr2 etc.
            </summary>
        </member>
        <member name="F:Bio.IO.BAM.BAMSortedIndex.sortField">
            <summary>
            Field name using which data is to be sorted.
            </summary>
        </member>
        <member name="F:Bio.IO.BAM.BAMSortedIndex.currentIndex">
            <summary>
            Holds current sorted index.
            </summary>
        </member>
        <member name="M:Bio.IO.BAM.BAMSortedIndex.#ctor(System.Collections.Generic.IList{System.String},Bio.IO.BAM.BAMSortByFields)">
            <summary>
            Constructor to initialize an instance of BAMSortedIndex class with specified list of filenames.
            </summary>
            <param name="filenames">Sorted filenames.</param>
            <param name="sortType">Type of sort required.</param>
        </member>
        <member name="M:Bio.IO.BAM.BAMSortedIndex.#ctor(System.String,Bio.IO.BAM.BAMSortByFields)">
            <summary>
            Constructor to initialize an instance of BAMSortedIndex class with specified filename.
            </summary>
            <param name="filename">Sorted filename.</param>
            <param name="sortType">Type of sort required.</param>
        </member>
        <member name="M:Bio.IO.BAM.BAMSortedIndex.Dispose">
            <summary>
            Disposes this object by discording any resources held.
            </summary>
        </member>
        <member name="M:Bio.IO.BAM.BAMSortedIndex.Dispose(System.Boolean)">
            <summary>
            Dispose field instances
            </summary>
            <param name="disposeManaged">If disposeManaged equals true, clean all resources</param>
        </member>
        <member name="M:Bio.IO.BAM.BAMSortedIndex.MoveNext">
            <summary>
            Fetches next sorted index.
            </summary>
            <returns>Returns true on successful fetch, else return false.</returns>
        </member>
        <member name="M:Bio.IO.BAM.BAMSortedIndex.Reset">
            <summary>
            Resets this instance to initial state.
            </summary>
        </member>
        <member name="M:Bio.IO.BAM.BAMSortedIndex.GetEnumerator">
            <summary>
            Returns the enumerator object
            </summary>
            <returns>enumerator object</returns>
        </member>
        <member name="M:Bio.IO.BAM.BAMSortedIndex.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns the enumerator object
            </summary>
            <returns></returns>
        </member>
        <member name="P:Bio.IO.BAM.BAMSortedIndex.GroupName">
            <summary>
            Gets or sets the Chromosome name of this Sorted BAM Indexer
            </summary>
        </member>
        <member name="P:Bio.IO.BAM.BAMSortedIndex.Current">
            <summary>
            Gets the current sorted index.
            </summary>
        </member>
        <member name="P:Bio.IO.BAM.BAMSortedIndex.System#Collections#IEnumerator#Current">
            <summary>
            Gets the current sorted index.
            </summary>
        </member>
        <member name="T:Bio.IO.BAM.BAMFormatterExtensions">
            <summary>
            Extensions specific to the BAMFormatter class.
            </summary>
        </member>
        <member name="M:Bio.IO.BAM.BAMFormatterExtensions.Format(Bio.IO.BAM.BAMFormatter,Bio.Algorithms.Alignment.ISequenceAlignment,System.String,System.String)">
            <summary>
            Write out the given SequenceAlignmentMap to the file
            </summary>
            <param name="formatter">BAMFormatter</param>
            <param name="sam">SequenceAlignmentMap</param>
            <param name="filename">File to write to</param>
            <param name="indexFilename">BAM index file</param>
        </member>
        <member name="M:Bio.IO.BAM.BAMFormatterExtensions.Format(Bio.IO.BAM.BAMFormatter,Bio.IO.SAM.SequenceAlignmentMap,System.String)">
            <summary>
            Write out the given SequenceAlignmentMap to the file
            </summary>
            <param name="formatter">BAMFormatter</param>
            <param name="sam">SequenceAlignmentMap</param>
            <param name="filename">File to write to</param>
        </member>
        <member name="T:Bio.IO.BAM.BAMParserExtensions">
            <summary>
            Parser extensions for the BAM parsers.
            </summary>
        </member>
        <member name="M:Bio.IO.BAM.BAMParserExtensions.Parse(Bio.IO.BAM.BAMParser,System.String)">
            <summary>
            Returns an iterator over a set of SAMAlignedSequences retrieved from a parsed BAM file.
            </summary>
            <param name="parser">Parser</param>
            <param name="filename">Filename</param>
            <returns>IEnumerable SAMAlignedSequence object.</returns>
        </member>
        <member name="M:Bio.IO.BAM.BAMParserExtensions.ParseRange(Bio.IO.BAM.BAMParser,System.String,System.String)">
            <summary>
            Parses specified BAM file using index file.
            Index file is assumed to be in the same location as that of the specified bam file with the name "filename".bai
            For example, if the specified bam file name is D:\BAMdata\sample.bam then index file name will be taken as D:\BAMdata\sample.bam.bai
            If index file is not available then this method throw an exception.
            </summary>
            <param name="parser">BAM parser</param>
            <param name="fileName">BAM file name.</param>
            <param name="refSeqName">Name of reference sequence.</param>
            <returns>SequenceAlignmentMap object which contains alignments for specified reference sequence.</returns>
        </member>
        <member name="M:Bio.IO.BAM.BAMParserExtensions.GetBAMIndexFileName(System.String)">
            <summary>
            Attempts to find the name of an index file for the given BAM file name, throws an error if none is found.
            </summary>
            <param name="fileName">The name of the BAM file.</param>
            <returns>The name of the index file for the given BAM file.</returns>
        </member>
        <member name="M:Bio.IO.BAM.BAMParserExtensions.ParseRange(Bio.IO.BAM.BAMParser,System.String,System.String,System.Int32,System.Int32)">
            <summary>
            Parses specified BAM file using index file.
            Index file is assumed to be in the same location as that of the specified bam file with the name "filename".bai
            For example, if the specified bam file name is D:\BAMdata\sample.bam then index file name will be taken as D:\BAMdata\sample.bam.bai
            If index file is not available then this method throw an exception.
            </summary>
            <param name="parser">BAM parser</param>
            <param name="fileName">BAM file name.</param>
            <param name="refSeqName">Name of reference sequence.</param>
            <param name="start">Start index.</param>
            <param name="end">End index.</param>
            <returns>SequenceAlignmentMap object which contains alignments overlaps with the specified start 
            and end co-ordinate of the specified reference sequence.</returns>
        </member>
        <member name="M:Bio.IO.BAM.BAMParserExtensions.ParseRange(Bio.IO.BAM.BAMParser,System.String,System.Int32)">
            <summary>
            Parses specified BAM file using index file.
            Index file is assumed to be in the same location as that of the specified bam file with the name "filename".bai
            For example, if the specified bam file name is D:\BAMdata\sample.bam then index file name will be taken as D:\BAMdata\sample.bam.bai
            If index file is not available then this method throw an exception.
            </summary>
            <param name="parser">BAM parser</param>
            <param name="fileName">BAM file name.</param>
            <param name="refSeqIndex">Index of reference sequence.</param>
            <returns>SequenceAlignmentMap object which contains alignments for specified reference sequence.</returns>
        </member>
        <member name="M:Bio.IO.BAM.BAMParserExtensions.ParseRange(Bio.IO.BAM.BAMParser,System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Parses specified BAM file using index file.
            Index file is assumed to be in the same location as that of the specified bam file with the name "filename".bai
            For example, if the specified bam file name is D:\BAMdata\sample.bam then index file name will be taken as D:\BAMdata\sample.bam.bai
            If index file is not available then this method throw an exception.
            </summary>
            <param name="parser">BAM parser</param>
            <param name="fileName">BAM file name.</param>
            <param name="refSeqIndex">Index of reference sequence.</param>
            <param name="start">Start index.</param>
            <param name="end">End index.</param>
            <returns>SequenceAlignmentMap object which contains alignments overlaps with the specified start 
            and end co-ordinate of the specified reference sequence.</returns>
        </member>
        <member name="M:Bio.IO.BAM.BAMParserExtensions.ParseRange(Bio.IO.BAM.BAMParser,System.String,Bio.SequenceRange)">
            <summary>
            Parses specified BAM file using index file.
            </summary>
            <param name="parser">BAM parser</param>
            <param name="fileName">BAM file name.</param>
            <param name="range">SequenceRange object which contains reference sequence name and start and end co-ordinates.</param>
            <returns>SequenceAlignmentMap object which contains alignments for specified reference sequence and for specified range.</returns>
        </member>
        <member name="T:Bio.FormatterExtensions">
            <summary>
            Generic formatter extensions
            </summary>
        </member>
        <member name="M:Bio.FormatterExtensions.Open``1(Bio.IO.IFormatter{``0},System.String)">
            <summary>
            Open a file and parse it with the formatter.
            </summary>
            <param name="formatter">Formatter</param>
            <param name="filename">Filename</param>
            <returns>IDisposable to close stream.</returns>
        </member>
        <member name="M:Bio.FormatterExtensions.Format``1(Bio.IO.IFormatter{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Writes a set of data to the formatter.
            </summary>
            <param name="formatter">Formatter</param>
            <param name="data">Data to write.</param>
        </member>
        <member name="M:Bio.FormatterExtensions.Format``1(Bio.IO.IFormatter{``0},``0)">
            <summary>
            Writes a single data element to the formatter.
            </summary>
            <param name="formatter">Formatter</param>
            <param name="data">Data</param>
        </member>
        <member name="M:Bio.FormatterExtensions.Format``1(Bio.IO.IFormatter{``0},System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Writes a set of data to the formatter.
            </summary>
            <param name="formatter">Formatter</param>
            <param name="data">Data to write.</param>
            <param name="filename">Filename</param>
        </member>
        <member name="M:Bio.FormatterExtensions.Format``1(Bio.IO.IFormatter{``0},``0,System.String)">
            <summary>
            Writes a single sequence to the formatter.
            </summary>
            <param name="formatter">Formatter</param>
            <param name="data">Sequence</param>
            <param name="filename">Filename</param>
        </member>
        <member name="M:Bio.FormatterExtensions.Close``1(Bio.IO.IFormatter{``0})">
            <summary>
            Closes the formatter.
            </summary>
            <param name="formatter">Formatter.</param>
        </member>
        <member name="M:Bio.FormatterExtensions.FormatString(Bio.IO.IPhylogeneticTreeFormatter,Bio.Phylogenetics.Tree)">
            <summary>
            Formats the Phylogenetic tree to a string.
            </summary>
            <param name="formatter">Sequence formatter</param>
            <param name="tree">Tree data</param>
            <returns></returns>
        </member>
        <member name="M:Bio.FormatterExtensions.FormatString``1(Bio.IO.IFormatter{``0},``0)">
            <summary>
            Formats the Wiggle annotation to a string.
            </summary>
            <param name="formatter"></param>
            <param name="data"></param>
        </member>
        <member name="M:Bio.FormatterExtensions.DoFormat``1(System.Action{System.IO.Stream,``0},``0)">
            <summary>
            Performs a format to a memory stream and returns the result as a string.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="formatter"></param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="T:Bio.IO.INamedStreamCreatorExtensions">
            <summary>
            Extensions related to INamedStreamCreator
            </summary>
        </member>
        <member name="M:Bio.IO.INamedStreamCreatorExtensions.ToNamedStreamCreatorFromFileName(System.String,System.String)">
            <summary>
            Turn a file name (a string) into a INamedStreamCreator
            </summary>
            <param name="fileName">The name of the file to turn into a INamedStreamCreator.</param>
            <param name="name">(Optional) The name of the INamedStreamCreator. If null, fileName is used.</param>
            <returns>a INamedStreamCreator</returns>
        </member>
        <member name="M:Bio.IO.INamedStreamCreatorExtensions.ToNamedStreamCreator(System.IO.FileInfo,System.String)">
            <summary>
            Turn a FileInfo into a INamedStreamCreator
            </summary>
            <param name="fileInfo">The FileInfo to turn into a INamedStreamCreator.</param>
            <param name="name">(Optional) The name of the INamedStreamCreator. If null, the FileInfo's name is used.</param>
            <returns>a INamedStreamCreator</returns>
        </member>
        <member name="M:Bio.IO.INamedStreamCreatorExtensions.ToNamedStreamCreator(System.Reflection.Assembly,System.String,System.String)">
            <summary>
            Turn a resource into a INamedStreamCreator
            </summary>
            <param name="assembly">The assembly containing the resource</param>
            <param name="resourceName">The name of the resource</param>
            <param name="name">(Optional) The name of the INamedStreamCreator. If null, resourceName is used.</param>
            <returns>a INamedStreamCreator</returns>
        </member>
        <member name="M:Bio.IO.INamedStreamCreatorExtensions.ToNamedStreamCreatorFromString(System.String,System.String)">
            <summary>
            Turn a string into a INamedStreamCreator. The string will be used as the data for the stream.
            </summary>
            <param name="text">The text to turn into a INamedStreamCreator.</param>
            <param name="name">(Optional) The name of the INamedStreamCreator. If null, string is used for both data and for the name.</param>
            <returns>a INamedStreamCreator</returns>
        </member>
        <member name="M:Bio.IO.INamedStreamCreatorExtensions.ReadEachUncommentedLine(Bio.IO.INamedStreamCreator)">
            <summary>
            Enumerates the lines of a INamedStreamCreator without comments.
            </summary>
            <param name="namedStreamCreator">The INamedStreamCreator to read from</param>
            <returns>an enumerator of lines</returns>
        </member>
        <member name="M:Bio.IO.INamedStreamCreatorExtensions.ReadEachLine(Bio.IO.INamedStreamCreator)">
            <summary>
            Enumerates the lines of a INamedStreamCreator.
            </summary>
            <param name="namedStreamCreator">The INamedStreamCreator to read from</param>
            <returns>an enumerator of lines</returns>
        </member>
        <member name="M:Bio.IO.INamedStreamCreatorExtensions.ReadUncommentedLine(Bio.IO.INamedStreamCreator)">
            <summary>
            Return the first line of namedStreamCreator after any comments.
            </summary>
            <param name="namedStreamCreator">The namedStreamCreator from which to read.</param>
            <returns>The first line of a file after skipping any comments.</returns>
        </member>
        <member name="M:Bio.IO.INamedStreamCreatorExtensions.OpenText(Bio.IO.INamedStreamCreator)">
            <summary>
            Open a INamedStreamCreator for reading as text. This should be used is a Using statement. (According to http://msdn.microsoft.com/en-us/library/hh40558e.aspx, the stream will be disposed of, too.)
            </summary>
            <param name="namedStreamCreator">The INamedStreamCreator to read from</param>
            <returns>a StreamReader</returns>
        </member>
        <member name="M:Bio.IO.INamedStreamCreatorExtensions.OpenUncommentedText(Bio.IO.INamedStreamCreator)">
            <summary>
            Open a INamedStreamCreator for reading as uncommented text. This should be used is a Using statement. (According to http://msdn.microsoft.com/en-us/library/hh40558e.aspx, the stream will be disposed of, too.)
            </summary>
            <param name="namedStreamCreator">The INamedStreamCreator to read from</param>
            <returns>a StreamReader</returns>
        </member>
        <member name="M:Bio.IO.INamedStreamCreatorExtensions.ReadToEnd(Bio.IO.INamedStreamCreator)">
            <summary>
            Returns all the data of a INamedStreamCreator as a string.
            </summary>
            <param name="namedStreamCreator">The INamedStreamCreator to read from</param>
            <returns>The data as text</returns>
        </member>
        <member name="M:Bio.IO.INamedStreamCreatorExtensions.WriteToStream(Bio.IO.INamedStreamCreator,System.IO.Stream)">
            <summary>
            Write the context of a INamedStreamCreator to a stream.
            </summary>
            <param name="namedStreamCreator">The INamedStreamCreator to read from</param>
            <param name="stream">The stream to write to</param>
        </member>
        <member name="T:Bio.ParserFormatterExtensions`1">
            <summary>
            Extensions to the parser/formatter framework to support Open/Close/Dispose semantics.
            </summary>
        </member>
        <member name="F:Bio.ParserFormatterExtensions`1.fileData">
            <summary>
            This associates some data to the given parser to hold the filename and filestream.
            </summary>
        </member>
        <member name="M:Bio.ParserFormatterExtensions`1.Open(`0,System.String)">
            <summary>
            Opens a sequence file using the parser.
            </summary>
            <param name="parser">Parser</param>
            <param name="filename">File to open</param>
            <returns>Disposable object to close the stream.</returns>
        </member>
        <member name="M:Bio.ParserFormatterExtensions`1.GetOpenStream(`0,System.Boolean)">
            <summary>
            Parses the sequences from the open file.
            </summary>
            <param name="parser">Sequence Parser</param>
            <param name="writable">True for a writable stream</param>
            <returns>Set of parsed sequences.</returns>
        </member>
        <member name="M:Bio.ParserFormatterExtensions`1.Close(`0)">
            <summary>
            Closes the parser.
            </summary>
            <param name="parser">Parser</param>
        </member>
        <member name="T:Bio.PhylogeneticTreeFormatterExtensions">
            <summary>
            Phylo Tree Formatter extensions.
            </summary>
        </member>
        <member name="M:Bio.PhylogeneticTreeFormatterExtensions.Open(Bio.IO.IPhylogeneticTreeFormatter,System.String)">
            <summary>
            Open a file and parse it with the formatter.
            </summary>
            <param name="formatter">Formatter</param>
            <param name="filename">Filename</param>
            <returns>IDisposable to close stream.</returns>
        </member>
        <member name="M:Bio.PhylogeneticTreeFormatterExtensions.Format(Bio.IO.IPhylogeneticTreeFormatter,Bio.Phylogenetics.Tree)">
            <summary>
            Writes a single data element to the formatter.
            </summary>
            <param name="formatter">Formatter</param>
            <param name="data">Tree Data</param>
        </member>
        <member name="M:Bio.PhylogeneticTreeFormatterExtensions.Format(Bio.IO.IPhylogeneticTreeFormatter,Bio.Phylogenetics.Tree,System.String)">
            <summary>
            Writes a single sequence to the formatter.
            </summary>
            <param name="formatter">Formatter</param>
            <param name="data">Tree data</param>
            <param name="filename">Filename</param>
        </member>
        <member name="M:Bio.PhylogeneticTreeFormatterExtensions.Close(Bio.IO.IPhylogeneticTreeFormatter)">
            <summary>
            Closes the formatter.
            </summary>
            <param name="formatter">Formatter.</param>
        </member>
        <member name="T:Bio.PhylogeneticTreeParserExtensions">
            <summary>
            Extensions for the Newick parser and variations.
            </summary>
        </member>
        <member name="M:Bio.PhylogeneticTreeParserExtensions.Open(Bio.IO.IPhylogeneticTreeParser,System.String)">
            <summary>
            Opens a sequence file using the parser.
            </summary>
            <param name="parser">Parser</param>
            <param name="filename">File to open</param>
            <returns>Disposable object to close the stream.</returns>
        </member>
        <member name="M:Bio.PhylogeneticTreeParserExtensions.Parse(Bio.IO.IPhylogeneticTreeParser)">
            <summary>
            Parses the sequences from the open file.
            </summary>
            <param name="parser">Sequence Parser</param>
            <returns>Set of parsed sequences.</returns>
        </member>
        <member name="M:Bio.PhylogeneticTreeParserExtensions.Parse(Bio.IO.IPhylogeneticTreeParser,System.String)">
            <summary>
            Parses the sequences from the open file.
            </summary>
            <param name="parser">Sequence Parser</param>
            <param name="filename">Filename to open</param>
            <returns>Set of parsed sequences.</returns>
        </member>
        <member name="M:Bio.PhylogeneticTreeParserExtensions.Close(Bio.IO.IPhylogeneticTreeParser)">
            <summary>
            Closes the parser.
            </summary>
            <param name="parser">Parser</param>
        </member>
        <member name="T:Bio.SequenceAlignmentFormatterExtensions">
            <summary>
            Extension methods for sequence formatters
            </summary>
        </member>
        <member name="M:Bio.SequenceAlignmentFormatterExtensions.Open(Bio.IO.ISequenceAlignmentFormatter,System.String)">
            <summary>
            Open a file and parse it with the sequence formatter.
            </summary>
            <param name="formatter">Formatter</param>
            <param name="filename">Filename</param>
            <returns>IDisposable to close stream.</returns>
        </member>
        <member name="M:Bio.SequenceAlignmentFormatterExtensions.Format(Bio.IO.ISequenceAlignmentFormatter,System.Collections.Generic.IEnumerable{Bio.Algorithms.Alignment.ISequenceAlignment})">
            <summary>
            Writes a set of sequences to the formatter.
            </summary>
            <param name="formatter">Formatter</param>
            <param name="sequences">Sequences to write.</param>
        </member>
        <member name="M:Bio.SequenceAlignmentFormatterExtensions.Format(Bio.IO.ISequenceAlignmentFormatter,Bio.Algorithms.Alignment.ISequenceAlignment)">
            <summary>
            Writes a single sequence to the formatter.
            </summary>
            <param name="formatter">Formatter</param>
            <param name="sequence">Sequence</param>
        </member>
        <member name="M:Bio.SequenceAlignmentFormatterExtensions.Format(Bio.IO.ISequenceAlignmentFormatter,System.Collections.Generic.IEnumerable{Bio.Algorithms.Alignment.ISequenceAlignment},System.String)">
            <summary>
            Writes a set of sequences to the formatter.
            </summary>
            <param name="formatter">Formatter</param>
            <param name="sequences">Sequences to write.</param>
            <param name="fileName">Filename to write to</param>
        </member>
        <member name="M:Bio.SequenceAlignmentFormatterExtensions.Format(Bio.IO.ISequenceAlignmentFormatter,Bio.Algorithms.Alignment.ISequenceAlignment,System.String)">
            <summary>
            Writes a sequence to the formatter.
            </summary>
            <param name="formatter">Formatter</param>
            <param name="sequence">Sequence to write.</param>
            <param name="fileName">Filename to write to</param>
        </member>
        <member name="M:Bio.SequenceAlignmentFormatterExtensions.Close(Bio.IO.ISequenceAlignmentFormatter)">
            <summary>
            Closes the formatter.
            </summary>
            <param name="formatter">Formatter.</param>
        </member>
        <member name="T:Bio.SequenceAlignmentParserExtensions">
            <summary>
            Extensions to the ISequenceAlignmentParser to support Open/Close/Dispose semantics.
            </summary>
        </member>
        <member name="M:Bio.SequenceAlignmentParserExtensions.Open(Bio.IO.ISequenceAlignmentParser,System.String)">
            <summary>
            Opens a sequence file using the parser.
            </summary>
            <param name="parser">Parser</param>
            <param name="filename">File to open</param>
            <returns>Disposable object to close the stream.</returns>
        </member>
        <member name="M:Bio.SequenceAlignmentParserExtensions.Parse(Bio.IO.ISequenceAlignmentParser)">
            <summary>
            Parses the sequences from the open file.
            </summary>
            <param name="parser">Sequence Parser</param>
            <returns>Set of parsed sequences.</returns>
        </member>
        <member name="M:Bio.SequenceAlignmentParserExtensions.ParseOne(Bio.IO.ISequenceAlignmentParser)">
            <summary>
            Parses the sequences from the open file.
            </summary>
            <param name="parser">Sequence Parser</param>
            <returns>Set of parsed sequences.</returns>
        </member>
        <member name="M:Bio.SequenceAlignmentParserExtensions.ParseOne(Bio.IO.ISequenceAlignmentParser,System.String)">
            <summary>
            Parses the sequences from the open file.
            </summary>
            <param name="parser">Sequence Parser</param>
            <param name="filename">File to parse</param>
            <returns>Set of parsed sequences.</returns>
        </member>
        <member name="M:Bio.SequenceAlignmentParserExtensions.ParseOne``1(Bio.IO.ISequenceAlignmentParser,System.String)">
            <summary>
            Parses the sequences from the open file.
            </summary>
            <param name="parser">Sequence Parser</param>
            <param name="filename">File to parse</param>
            <returns>Set of parsed sequences.</returns>
        </member>
        <member name="M:Bio.SequenceAlignmentParserExtensions.Parse(Bio.IO.ISequenceAlignmentParser,System.String)">
            <summary>
            Parses the sequences from the given filename.
            </summary>
            <param name="parser">Sequence Parser</param>
            <param name="fileName">Filename to open/close</param>
            <returns>Set of parsed sequences.</returns>
        </member>
        <member name="M:Bio.SequenceAlignmentParserExtensions.Close(Bio.IO.ISequenceAlignmentParser)">
            <summary>
            Closes the parser.
            </summary>
            <param name="parser">Parser</param>
        </member>
        <member name="T:Bio.ParserExtensions">
            <summary>
            Extensions to the IParser(T) to support Open/Close/Dispose semantics.
            </summary>
        </member>
        <member name="M:Bio.ParserExtensions.Open``1(Bio.IO.IParser{``0},System.String)">
            <summary>
            Opens a sequence file using the parser.
            </summary>
            <param name="parser">Parser</param>
            <param name="filename">File to open</param>
            <returns>Disposable object to close the stream.</returns>
        </member>
        <member name="M:Bio.ParserExtensions.Parse``1(Bio.IO.IParser{``0})">
            <summary>
            Parses the data from the open file.
            </summary>
            <param name="parser">Parser</param>
            <returns>Set of parsed data elements.</returns>
        </member>
        <member name="M:Bio.ParserExtensions.ParseOne``1(Bio.IO.IParser{``0})">
            <summary>
            Parses the data from the open file.
            </summary>
            <param name="parser">Parser</param>
            <returns>Set of parsed data elements.</returns>
        </member>
        <member name="M:Bio.ParserExtensions.Parse``1(Bio.IO.IParser{``0},System.String)">
            <summary>
            Parses the sequences from the given filename.
            </summary>
            <param name="parser">Parser</param>
            <param name="fileName">Filename to open/close</param>
            <returns>Set of parsed data elements.</returns>
        </member>
        <member name="M:Bio.ParserExtensions.ParseOne``1(Bio.IO.IParser{``0},System.String)">
            <summary>
            Parses the sequences from the given filename.
            </summary>
            <param name="parser">Parser</param>
            <param name="fileName">Filename to open/close</param>
            <returns>Set of parsed data elements.</returns>
        </member>
        <member name="M:Bio.ParserExtensions.Close``1(Bio.IO.IParser{``0})">
            <summary>
            Closes the parser.
            </summary>
            <param name="parser">Parser</param>
        </member>
        <member name="T:Bio.SequenceRangeFormatterExtensions">
            <summary>
            Extensions for the SequenceRange Formatters.
            </summary>
        </member>
        <member name="M:Bio.SequenceRangeFormatterExtensions.Format(Bio.IO.ISequenceRangeFormatter,System.Collections.Generic.IList{Bio.ISequenceRange},System.String)">
            <summary>
            Formats a given ISequenceRange to the given formatter and filename.
            </summary>
            <param name="formatter">Formatter</param>
            <param name="ranges">ISequenceRange elements</param>
            <param name="filename">Filename to write to</param>
        </member>
        <member name="M:Bio.SequenceRangeFormatterExtensions.Format(Bio.IO.ISequenceRangeFormatter,Bio.SequenceRangeGrouping,System.String)">
            <summary>
            Writes out a grouping of ISequenceRange objects to a specified
            text writer.
            </summary>
        </member>
        <member name="T:Bio.SequenceRangeParserExtensions">
            <summary>
            SequenceRange Parser extensions.
            </summary>
        </member>
        <member name="M:Bio.SequenceRangeParserExtensions.ParseRange(Bio.IO.ISequenceRangeParser,System.String)">
            <summary>
            Parse a set of ISequenceRange objects from a stream.
            </summary>
        </member>
        <member name="M:Bio.SequenceRangeParserExtensions.ParseRangeGrouping(Bio.IO.ISequenceRangeParser,System.String)">
            <summary>
            Parse a set of ISequenceRange objects into a SequenceRange
            grouping from a stream.
            </summary>
        </member>
        <member name="T:Bio.IO.Wiggle.WiggleFormatterExtensions">
            <summary>
            Extension methods for sequence formatters
            </summary>
        </member>
        <member name="M:Bio.IO.Wiggle.WiggleFormatterExtensions.Open(Bio.IO.Wiggle.WiggleFormatter,System.String)">
            <summary>
            Open a file and parse it with the sequence formatter.
            </summary>
            <param name="formatter">Formatter</param>
            <param name="filename">Filename</param>
            <returns>IDisposable to close stream.</returns>
        </member>
        <member name="M:Bio.IO.Wiggle.WiggleFormatterExtensions.Format(Bio.IO.Wiggle.WiggleFormatter,System.Collections.Generic.IEnumerable{Bio.IO.Wiggle.WiggleAnnotation})">
            <summary>
            Writes a set of sequences to the formatter.
            </summary>
            <param name="formatter">Formatter</param>
            <param name="annotations">Wiggle annotations to write.</param>
        </member>
        <member name="M:Bio.IO.Wiggle.WiggleFormatterExtensions.Format(Bio.IO.Wiggle.WiggleFormatter,Bio.IO.Wiggle.WiggleAnnotation)">
            <summary>
            Writes a single sequence to the formatter.
            </summary>
            <param name="formatter">Formatter</param>
            <param name="annotation">Wiggle Annotation</param>
        </member>
        <member name="M:Bio.IO.Wiggle.WiggleFormatterExtensions.Format(Bio.IO.Wiggle.WiggleFormatter,System.Collections.Generic.IEnumerable{Bio.IO.Wiggle.WiggleAnnotation},System.String)">
            <summary>
            Writes a set of sequences to the formatter.
            </summary>
            <param name="formatter">Formatter</param>
            <param name="annotations">Wiggle annotations to write.</param>
            <param name="filename">Filename to write to</param>
        </member>
        <member name="M:Bio.IO.Wiggle.WiggleFormatterExtensions.Format(Bio.IO.Wiggle.WiggleFormatter,Bio.IO.Wiggle.WiggleAnnotation,System.String)">
            <summary>
            Writes a single sequence to the formatter.
            </summary>
            <param name="formatter">Formatter</param>
            <param name="annotation">Wiggle Annotation</param>
            <param name="filename">Filename</param>
        </member>
        <member name="M:Bio.IO.Wiggle.WiggleFormatterExtensions.Close(Bio.IO.Wiggle.WiggleFormatter)">
            <summary>
            Closes the formatter.
            </summary>
            <param name="formatter">Formatter.</param>
        </member>
        <member name="T:Bio.IO.Wiggle.WiggleParserExtensions">
            <summary>
            Extensions to the WiggleParser to support Open/Close/Dispose semantics.
            </summary>
        </member>
        <member name="M:Bio.IO.Wiggle.WiggleParserExtensions.Open(Bio.IO.Wiggle.WiggleParser,System.String)">
            <summary>
            Opens a sequence file using the parser.
            </summary>
            <param name="parser">Parser</param>
            <param name="filename">File to open</param>
            <returns>Disposable object to close the stream.</returns>
        </member>
        <member name="M:Bio.IO.Wiggle.WiggleParserExtensions.Parse(Bio.IO.Wiggle.WiggleParser)">
            <summary>
            Parses the sequences from the open file.
            </summary>
            <param name="parser">Sequence Parser</param>
            <returns>Set of parsed sequences.</returns>
        </member>
        <member name="M:Bio.IO.Wiggle.WiggleParserExtensions.Parse(Bio.IO.Wiggle.WiggleParser,System.String)">
            <summary>
            Parses the sequences from the given filename.
            </summary>
            <param name="parser">Sequence Parser</param>
            <param name="fileName">Filename to open/close</param>
            <returns>Set of parsed sequences.</returns>
        </member>
        <member name="M:Bio.IO.Wiggle.WiggleParserExtensions.ParseOne(Bio.IO.Wiggle.WiggleParser,System.String)">
            <summary>
            Parses the sequences from the given filename.
            </summary>
            <param name="parser">Sequence Parser</param>
            <param name="fileName">Filename to open/close</param>
            <returns>Set of parsed sequences.</returns>
        </member>
        <member name="M:Bio.IO.Wiggle.WiggleParserExtensions.Close(Bio.IO.Wiggle.WiggleParser)">
            <summary>
            Closes the parser.
            </summary>
            <param name="parser">Parser</param>
        </member>
        <member name="T:Bio.IO.Xsv.XsvContigFormatterExtensions">
            <summary>
            Formatter extensions for the XsvContigFormatter
            </summary>
        </member>
        <member name="M:Bio.IO.Xsv.XsvContigFormatterExtensions.Format(Bio.IO.Xsv.XsvContigFormatter,Bio.Algorithms.Assembly.Contig,System.String)">
            <summary>
            Write out a set of contigs to the given file.
            </summary>
            <param name="formatter">Formatter</param>
            <param name="contig">Contig to write</param>
            <param name="filename">Filename</param>
        </member>
        <member name="M:Bio.IO.Xsv.XsvContigFormatterExtensions.Format(Bio.IO.Xsv.XsvContigFormatter,Bio.Algorithms.Assembly.Contig)">
            <summary>
            Write out a set of contigs to the given file.
            </summary>
            <param name="formatter">Formatter</param>
            <param name="contig">Contig to write</param>
        </member>
        <member name="T:Bio.IO.Xsv.XsvContigParserExtensions">
            <summary>
            XsvContigParser extensions
            </summary>
        </member>
        <member name="M:Bio.IO.Xsv.XsvContigParserExtensions.ParseContig(Bio.IO.Xsv.XsvContigParser,System.String)">
            <summary>
            Parse out a Contig from the given file.
            </summary>
            <param name="parser">Parser</param>
            <param name="filename">Filename</param>
            <returns>Contig</returns>
        </member>
        <member name="T:Bio.Util.CommentedStreamReader">
            <summary>
                A stream reader that can skip over comments in the input.
            </summary>
        </member>
        <member name="F:Bio.Util.CommentedStreamReader.CommentHeader">
            <summary>
            The string that tells the parser how comments are marked.
            </summary>
        </member>
        <member name="M:Bio.Util.CommentedStreamReader.#ctor(System.IO.FileInfo)">
            <summary>
                Create a CommentedStreamReader from a FileInfo
            </summary>
            <param name="fileInfo">The fileinfo to read.</param>
        </member>
        <member name="M:Bio.Util.CommentedStreamReader.#ctor(System.String)">
            <summary>
                Create a CommentedStreamReader from a file
            </summary>
            <param name="filename">The file to read</param>
        </member>
        <member name="M:Bio.Util.CommentedStreamReader.#ctor(System.IO.Stream)">
            <summary>
                Create a CommentedStreamReader from a stream
            </summary>
            <param name="stream">The stream to create a CommentedStreamReader from</param>
        </member>
        <member name="M:Bio.Util.CommentedStreamReader.#ctor(System.IO.TextReader)">
            <summary>
                Create a CommentedStreamReader from a TextReader. Loads the entire contents of the text reader into memory.
            </summary>
            <param name="reader">The TextReader to create a CommentedStreamReader from</param>
        </member>
        <member name="M:Bio.Util.CommentedStreamReader.ReadLine">
            <summary>
                Returns the next noncomment line
            </summary>
            <returns>The next noncomment line</returns>
        </member>
        <member name="M:Bio.Util.CommentedStreamReader.ReadCommentLine">
            <summary>
                Returns the next comment line
            </summary>
            <returns>A comment line</returns>
        </member>
        <member name="M:Bio.Util.CommentedStreamReader.ReadCommentOrNonCommentLine(System.Boolean)">
            <summary>
                Read the next line
            </summary>
            <param name="returnComment">if true, returns the next comment line; otherwise, returns the next noncomment line.</param>
            <returns>the next line</returns>
        </member>
        <member name="M:Bio.Util.CommentedStreamReader.Read">
            <summary>
            Reads the next character from the input stream and advances the character position by one character.
            </summary>
            <returns>
            The next character from the input stream represented as an <see cref="T:System.Int32"/> object, or -1 if no more characters are available.
            </returns>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception><filterpriority>1</filterpriority>
        </member>
        <member name="M:Bio.Util.CommentedStreamReader.Read(System.Char[],System.Int32,System.Int32)">
            <summary>
            Reads a specified maximum of characters from the current stream into a buffer, beginning at the specified index.
            </summary>
            <returns>
            The number of characters that have been read, or 0 if at the end of the stream and no data was read. The number will be less than or equal to the <paramref name="count"/> parameter, depending on whether the data is available within the stream.
            </returns>
            <param name="buffer">When this method returns, contains the specified character array with the values between <paramref name="index"/> and (<paramref name="count"/>) replaced by the characters read from the current source. </param><param name="index">The index of <paramref name="buffer"/> at which to begin writing. </param><param name="count">The maximum number of characters to read. </param><exception cref="T:System.ArgumentException">The buffer length minus <paramref name="index"/> is less than <paramref name="count"/>. </exception><exception cref="T:System.ArgumentNullException"><paramref name="buffer"/> is null. </exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> or <paramref name="count"/> is negative. </exception><exception cref="T:System.IO.IOException">An I/O error occurs, such as the stream is closed. </exception><filterpriority>1</filterpriority>
        </member>
        <member name="M:Bio.Util.CommentedStreamReader.Peek">
            <summary>
            Returns the next available character but does not consume it.
            </summary>
            <returns>
            An integer representing the next character to be read, or -1 if there are no characters to be read or if the stream does not support seeking.
            </returns>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception><filterpriority>1</filterpriority>
        </member>
        <member name="M:Bio.Util.CommentedStreamReader.ReadBlock(System.Char[],System.Int32,System.Int32)">
            <summary>
            Reads a specified maximum number of characters from the current stream and writes the data to a buffer, beginning at the specified index.
            </summary>
            <returns>
            The number of characters that have been read. The number will be less than or equal to <paramref name="count"/>, depending on whether all input characters have been read.
            </returns>
            <param name="buffer">When this method returns, contains the specified character array with the values between <paramref name="index"/> and (<paramref name="count"/>) replaced by the characters read from the current source.</param><param name="index">The position in <paramref name="buffer"/> at which to begin writing.</param><param name="count">The maximum number of characters to read.</param><exception cref="T:System.ArgumentNullException"><paramref name="buffer"/> is null. </exception><exception cref="T:System.ArgumentException">The buffer length minus <paramref name="index"/> is less than <paramref name="count"/>. </exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> or <paramref name="count"/> is negative. </exception><exception cref="T:System.ObjectDisposedException">The <see cref="T:System.IO.StreamReader"/> is closed. </exception><exception cref="T:System.IO.IOException">An I/O error occurred. </exception>
        </member>
        <member name="M:Bio.Util.CommentedStreamReader.ReadToEnd">
            <summary>
            Reads all characters from the current position to the end of the stream.
            </summary>
            <returns>
            The rest of the stream as a string, from the current position to the end. If the current position is at the end of the stream, returns an empty string ("").
            </returns>
            <exception cref="T:System.OutOfMemoryException">There is insufficient memory to allocate a buffer for the returned string. </exception><exception cref="T:System.IO.IOException">An I/O error occurs. </exception><filterpriority>1</filterpriority>
        </member>
        <member name="M:Bio.Util.CommentedStreamReader.ReadAllComments">
            <summary>
                Read all the comments from the stream
            </summary>
            <returns>A sequence of comment lines.</returns>
        </member>
        <member name="P:Bio.Util.CommentedStreamReader.CommentToken">
            <summary>
                The string used to mark a line as a comment line.
            </summary>
        </member>
        <member name="T:Bio.Util.FileAccessComparer">
            <summary>
            Compare FileInfo for equal file access capabilities
            </summary>
        </member>
        <member name="M:Bio.Util.FileAccessComparer.Equals(System.IO.FileInfo,System.IO.FileInfo)">
            <summary>
            Compare for file equality using name and timestamps
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns> bool true if FileInfo name and LastWriteTimes are equal, otherwise false </returns>
        </member>
        <member name="M:Bio.Util.FileAccessComparer.GetHashCode(System.IO.FileInfo)">
            <summary>
            Returns HashCode from FileInfo.Name
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="T:Bio.Util.FileUtils">
            <summary>
            A static class of methods related to files.
            </summary>
        </member>
        <member name="F:Bio.Util.FileUtils.CommentHeader">
            <summary>
            The string that tells the parser how comments are marked.
            </summary>
        </member>
        <member name="M:Bio.Util.FileUtils.OpenTextStripComments(System.String)">
            <summary>
            Given a (possibly compressed) file with possible comments, return a StreamReader with uncompressed, uncommented text.
            </summary>
            <param name="filename">The file to open</param>
            <returns>a StreamReader with uncompressed, uncommented text.</returns>
        </member>
        <member name="M:Bio.Util.FileUtils.OpenTextStripComments(System.IO.FileInfo,System.Boolean)">
            <summary>
            Given a (possibly compressed) FileInfo with possible comments, return a StreamReader with uncompressed, uncommented text.
            </summary>
            <param name="fileInfo">The FileInfo to open</param>
            <param name="allowGzip">(Optional) Tells if should uncompress files with names ending in ".gz" or ".gzip".</param>
            <returns>a StreamReader with uncompressed, uncommented text.</returns>
        </member>
        <member name="M:Bio.Util.FileUtils.StripComments(System.IO.Stream)">
            <summary>
            Filter the comments out of a stream.
            </summary>
            <param name="stream">The steam to filter</param>
            <returns>a StreamReader that skips over comments</returns>
        </member>
        <member name="M:Bio.Util.FileUtils.ReadLine(System.IO.FileInfo)">
            <summary>
            Read the first line of a file after any comments.
            </summary>
            <param name="file">The FileInfo from which to read.</param>
            <returns>The first line of a file after skipping any comments.</returns>
        </member>
        <member name="M:Bio.Util.FileUtils.ReadLine(Bio.IO.INamedStreamCreator)">
            <summary>
            Read the first line of a namedStreamCreator after any comments.
            </summary>
            <param name="namedStreamCreator">The namedStreamCreator from which to read.</param>
            <returns>The first line of a file after skipping any comments.</returns>
        </member>
        <member name="M:Bio.Util.FileUtils.ReadLine(System.String)">
            <summary>
            Read the first line of a file after any comments.
            </summary>
            <param name="filename">A name of the file from which to read</param>
            <returns>The first line of a file after skipping any comments.</returns>
        </member>
        <member name="M:Bio.Util.FileUtils.ReadEachLine(System.String)">
            <summary>
            </summary>
            <param name="fileName">The name of the file from which to read.</param>
            <returns>a sequence of lines from a file</returns>
        </member>
        <member name="M:Bio.Util.FileUtils.ReadEachLine(System.IO.TextReader)">
            <summary>
            Returns a sequence of lines from a TextReader.
            </summary>
            <param name="textReader">A textReader from which to read lines.</param>
            <returns>a sequence of lines from a TextReader</returns>
        </member>
        <member name="M:Bio.Util.FileUtils.ReadEachLine(System.IO.FileInfo)">
            <summary>
            Returns a sequence of lines from a file.
            </summary>
            <param name="fileInfo">A FileInfo from which to read lines.</param>
            <returns>a sequence of lines from a file</returns>
        </member>
        <member name="M:Bio.Util.FileUtils.ReadEachIndexedLine(System.String)">
            <summary>
            Returns the lines of a file as a pair with both lines and their index number
            </summary>
            <param name="fileName">The name of the file to read.</param>
            <returns>A sequence of KeyValuePair's. The key is the line and the value is the index number.</returns>
        </member>
        <member name="M:Bio.Util.FileUtils.ReadEachIndexedLine(System.IO.TextReader)">
            <summary>
            Returns the lines of a TextReader as a pair with both lines and their index number
            </summary>
            <param name="textReader">The TextReader that is the source of lines.</param>
            <returns>A sequence of KeyValuePair's. The key is the line and the value is the index number.</returns>
        </member>
        <member name="M:Bio.Util.FileUtils.ReadEachIndexedLine(System.IO.FileInfo)">
            <summary>
            Returns the lines of a file as a pair with both lines and their index number
            </summary>
            <param name="file">A FileInfo to read from</param>
            <returns>A sequence of KeyValuePair's. The key is the line and the value is the index number.</returns>
        </member>
        <member name="M:Bio.Util.FileUtils.GetTextReaderWithExternalReadWriteAccess(System.String)">
            <summary>
            Read a file stripping out comment, but with ReadWrite sharing.
            </summary>
            <param name="filename">The file to read</param>
            <returns>A StreamReader</returns>
        </member>
        <member name="M:Bio.Util.FileUtils.GetFiles(System.String,System.Boolean)">
            <summary>
            Get all the files that fit a pattern. The patterns can contain '*' as a wildcard. Patterns can
            include directories. Patterns can be combined into larger patterns with '+'
            </summary>
            <param name="inputPattern">A file pattern.</param>
            <param name="zeroIsOK">True if its OK that no actual files match the pattern between '+''s.</param>
            <returns>The names of actual files that match the pattern.</returns>
        </member>
        <member name="M:Bio.Util.FileUtils.CreateDirectoryForFileIfNeeded(System.String)">
            <summary>
            Create a directory for a file if the file's directory does not already exist.
            </summary>
            <param name="fileName">The file to create a directory for.</param>
        </member>
        <member name="M:Bio.Util.FileUtils.CreateDirectoryForFileIfNeeded(System.IO.FileInfo)">
            <summary>
            Creates a directory for a file if the file's directory does not already exist.
            </summary>
            <param name="fileInfo">The file for while the directory will be created.</param>
        </member>
        <member name="M:Bio.Util.FileUtils.GetEntryOrCallingAssembly">
            <summary>
            Returns the assembly in which program execution began. If no such assembly exists (for example, if this is running in Silverlight), then returns the calling assembly.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Bio.Util.FileUtils.GetDirectoryName(System.String)">
            <summary>
            Returns the directory/path name for the specified file
            </summary>
            <param name="exampleFileToCopy"> name of source file</param>
            <returns> string holding the path</returns>
        </member>
        <member name="M:Bio.Util.FileUtils.GetDirectoryName(System.String,System.String)">
            <summary>
            Returns the normalized directory/path name for the combined string workingDirectory + exampleFileToCopy
            </summary>
            <param name="exampleFileToCopy"> name of source file</param>
            <param name="workingDirectory"> name of path to source file</param>
            <returns> string holding the normalized path</returns>
        </member>
        <member name="M:Bio.Util.FileUtils.TryToOpenFile(System.String,System.TimeSpan,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.IO.FileStream@)">
            <summary>
            Keep trying to open file with a timeout
            </summary>
            <param name="filename"></param>
            <param name="timeout"></param>
            <param name="fileMode"></param>
            <param name="fileAcces"></param>
            <param name="fileShare"></param>
            <param name="filestream"></param>
            <returns>bool true if successfully opened, otherwise false</returns>
        </member>
    </members>
</doc>
